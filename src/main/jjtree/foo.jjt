
options {
	LOOKAHEAD = 2;
	STATIC = false;
}

PARSER_BEGIN(FooParser)
package com;
import java.io.StringBufferInputStream;
import com.ast.*;

public class FooParser {
	public static final String TEST_DATA = 
	"XXROUTINE ;c\r\n"+
	" ;comment\r\n"+
//	" B \r\n"+
//	" C \r\n"+
//	" Q:'(1+2!3_4+5-6*7/8#9\\10**11=12<13>14]15[16]]17&18!19+\"20\") \r\n"
//	" F \r\n"+
//	" F name=1:2 Q:0 \r\n"+
//	" K:name @name,name2,^aa,(a,b),p(3),^q(3,4),^$CHARACTER \r\n"
//	" I 1,\"false\",@foo,(1+name),p(3) \r\n"
//	" C foo \r\n"
//	" D foo \r\n"
//	" G:1 foo:0,bar:(quack+1) \r\n"
//	" H:0 \r\n"
//	" M:0 @bar,foo=^bar(12) \r\n"
//	" N foo \r\n"
	" S (foo,bar)=3,$X=2,$Y=3,$DEVICE=4,$KEY=5,$ECODE=6,$ETRAP=7,$P(foo,\"^\",3)=\"3\",$E(bar,\"^\")=9 \r\n"
//	" R foo,bar#2,*q \r\n"
//	" U foo \r\n"
//	" O foo \r\n"
//	" W:0 foo,*foo \r\n"
//	" X bob \r\n"
//	" L foo \r\n"
//	" J ^foo(1) \r\n"
	;

	public static void main(String[] args) {
		FooParser fp = new FooParser(new StringBufferInputStream(TEST_DATA));
		
		try {
			SimpleNode parseTree = fp.routine();
			// test comment
			parseTree.dump("");
			
		} catch (ParseException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		System.out.println("accept");
	}
}

PARSER_END(FooParser)



// basic commands
TOKEN : {
   < BREAK : "B"("REAK")? >
 | < CLOSE : "C"("LOSE")? >
 | < DO : "D"("O")? >
 | < ELSE : "E"("LSE")? >
 | < FOR : "F"("OR")? >
 | < GOTO : "G"("OTO")? >
 | < HALT: "H"("ALT"|"ANG")?>
 | < IF : "I"("F")? >
 | < JOB : "J"("OB")? >
 | < KILL : "K"("ILL")? >
 | < LOCK : "L"("OCK")? >
 | < MERGE : "M"("ERGE")? >
 | < NEW : "N"("EW")? >
 | < OPEN : "O"("PEN")? >
 | < QUIT : "Q"("UIT")? >
 | < READ : "R"("EAD")? >
 | < SET : "S"("ET")? >
 | < USE : "U"("SE")? >
 | < VIEW : "V"("IEW")? >
 | < WRITE : "W"("RITE")? >
 | < XECUTE : "X"("ECUTE")? >
}

// built-in functions
TOKEN : {
   < F_ASCII : "$A"("SCII")? >
 | < F_CHAR : "$C"("HAR")? >
 | < F_DATA : "$D"("ATA")? >
 | < F_EXTRACT : "$E"("XTRACT")? >
 | < F_FIND : "$F"("IND")? >
 | < F_FNUMBER : "$FN"("UMBER")? >
 | < F_GET : "$G"("ET")? >
 | < F_JUSTIFY : "$J"("USTIFY")? >
 | < F_LENGTH : "$L"("ENGTH")? >
 | < F_NAME : "$NA"("ME")? >
 | < F_ORDER : "$O"("RDER")? >
 | < F_PIECE : "$P"("IECE")? >
 | < F_QLENGTH : "$QL"("ENGTH")? >
 | < F_QSUBSCRIPT : "$QS"("UBSCRIPT")? >
 | < F_QUERY : "$Q"("UERY")? >
 | < F_RANDOM : "$R"("ANDOM")? >
 | < F_REVERSE : "$RE"("VERSE")? >
 | < F_SELECT : "$S"("ELECT")? >
 | < F_STACK : "$ST"("ACK")? >
 | < F_TEXT : "$T"("EXT")? >
 | < F_TRANSLATE : "$TR"("ANSLATE")? >
 | < F_VIEW : "$V"("IEW")? >
}

// built-in variables
TOKEN : {
    <V_DEVICE : "$D"("EVICE")? >
  | <V_ECODE : "$EC"("ODE")? >
  | <V_ESTACK : "$ES"("TACK")? >
  | <V_ETRAP : "$ET"("RAP")? >
  | <V_HORLOG : "$H"("ORLOG")? >
  | <V_IO : "$I"("O")? >
  | <V_JOB : "$J"("OB")? >
  | <V_KEY : "$K"("EY")? >
  | <V_PRINCIPAL : "$P"("RINCIPAL")? >
  | <V_QUIT : "$Q"("UIT")? >
  | <V_REFERENCE : "$R"("EFERENCE")? >
  | <V_STORAGE : "$S"("TORAGE")? >
  | <V_SYSTEM : "$SY"("STEM")? >
  | <V_TEST : "$T"("EST")? >
  | <V_X : "$X" >
  | <V_Y : "$Y" >
}

// structured system variables
TOKEN : {
    <SV_CHARACTER : "$C"("HARACTER")? >
  | <SV_DEVICE : "$D"("EVICE")? >
  | <SV_GLOBAL : "$G"("LOBAL")? >
  | <SV_JOB : "$J"("OB")? >
  | <SV_LOCK : "$L"("OCK")? >
  | <SV_ROUTINE : "$R"("OUTINE")? >
//  | <SV_SYSTEM : "$S"("YSTEM")? >
  // ^$Zunspecified ??
}

// identifiers
TOKEN : {
   < NAME : ("%"|<LETTER>)(<LETTER>|<DIGIT>)* >  // not strictly correct since "%" isn't a valid name
  | <STRLIT : "\"" (["a"-"z","A"-"Z","0"-"9","^"])* "\"" > 
}

// lexical tokens
TOKEN : {
   < EOL : "\r\n" >
 | < EOR : "\r\f" >
 | < COMMENT : ";" (~["\r"])* >
 | < #LETTER : ["a"-"z","A"-"Z"] >
 | <NUMBER : (<DIGIT>)+ > 
 | < DIGIT : ["0"-"9"] >
}

SimpleNode routine() : {}
{
	routinehead()
	routinebody()
	{ return jjtThis; }
}

void routinehead() : {}
{
	<NAME> ( (" ")* <COMMENT>)? <EOL>
	{
		System.out.println("routinehead()");
	}
}

void routinebody() : {}
{
	( line() )* ( <EOR> | <EOF> )
	{
		System.out.println("routinebody()");
	}
}

void line() : {}
{
	levelline() | formalline() 
}

void levelline() : {}
{
	( label() )? " " ( li() " " )* linebody()
	{
		System.out.println("levelline()");
	}
}

void label() : {}
{
	 <NAME> | <NUMBER>
	{
		System.out.println("label()");
	}
}

void li() : {}
{
	"."
	{
		System.out.println("li()");
	}
}

void formalline() : {}
{
	label() formallist() (" ")+ linebody()
	{
		System.out.println("formalline()");
	}
}

void linebody() : {}
{
	<COMMENT> <EOL>
	| commandscomment() 
	| commandsextsyntax()
}

void formallist() : {}
{
	"(" (<NAME> ( formallistitem() )* )? ")"
	{
		System.out.println("formallist()");
	}
}

void formallistitem() : {}
{
	"," <NAME>
	{
		System.out.println("formallistitem()");
	}
}

void commandscomment() : {}
{
	commands() (" ")* (<COMMENT> | extsyntax())? <EOL>
	{
		System.out.println("commandscomment()");
	}
}

void commandsextsyntax() : {}
{
	extsyntax() <EOL>
	{
		System.out.println("commandsextsyntax()");
	}
}

void commands() : {}
{
	command() ( (" ")* command() )*
	{
		System.out.println("commands()");
	}
}

void command() : { System.err.println("command()");
}
{
	breakcommand() //*
	| closecommand() //*
	| docommand() //*
	| elsecommand() //*
	| forcommand() //*
	| gotocommand() //*
	| haltcommand() //*
	| ifcommand() //*
	| jobcommand() //*
	| killcommand() //*
	| lockcommand() //*
	| mergecommand() //*
	| newcommand() //*
	| opencommand() //*
	| quitcommand() //*
	| readcommand() //*
	| setcommand() //*
	| usecommand() //*
	| viewcommand() //*
	| writecommand() //*
	| xecutecommand() //*
}

void extsyntax() : {}  // TODO
{
	"&SQL" "(" (".")* ")" 
	{
		System.out.println("extsyntax()");
	}
}

BreakCommand breakcommand() : {
PostCondition node1 = null;
}
{
	<BREAK> ( node1=postcond() )? (" ")*
	{
		return new BreakCommand(node1);
	}
}

CloseCommand closecommand() : {
PostCondition node1 = null;
}
{
	<CLOSE> ( node1=postcond() )? " " closearglist()
	{
// TODO: implement
		CloseCommand node = new CloseCommand(node1);
		return node;
	}
}

void closearglist() : {}
{
	closearg() ( "," closearg() )*
	{
		System.err.println("closearglist()");
	}
}

void closearg() : {}
{
	"@" expratom()
	| expr() ( ":" deviceparams() )?
}

void deviceparams() : {}
{
	deviceparam()
	{
		System.err.println("deviceparams()");
	}
	// TODO there's also the (param : param : param ...)  notation
}

void deviceparam() : {}
{
	<NAME> "=" expr()
	| <NAME>
	| expr()
}

DoCommand docommand() : {
PostCondition node1 = null;
}
{
	<DO> ( node1=postcond() )? ( (" " doarglist() ) | (" ")? )
	{
// TODO: implement
		DoCommand node = new DoCommand(node1);
		return node;
	}
}

void doarglist() : {}
{
	doarg() ( "," doarg() )*
}

void doarg() : {}
{
	"@" expratom()
	| entryref()
}

void entryref() : {}
{
	// TODO
	"^" <NAME>
	{
	}
	| <NAME>  ( "+" <NUMBER> )?  ( "^" <NAME> )?
	{
	}
}

ElseCommand elsecommand() : {}
{
	<ELSE> (" ")*
	{
// TODO: implement
		ElseCommand node = new ElseCommand();
		return node;
	}
}

ForCommand forcommand() : {}
{
	LOOKAHEAD( 3 )
	<FOR> " " lvn() "=" expr() ( ":" expr() )? ( ":" expr() )?
	{
// TODO: implement
		ForCommand node = new ForCommand();
		return node;
	}
	| <FOR> (" ")*
	{
// TODO: implement
		ForCommand node = new ForCommand();
		return node;
	}
}

GotoCommand gotocommand() : {
PostCondition node1 = null;
}
{
	<GOTO> ( node1=postcond() )? " " gotoargs()
	{
// TODO: implement
		GotoCommand node = new GotoCommand(node1);
		return node;
	}
}

void gotoargs() : {}
{
	gotoarg() ( "," gotoarg() )*
}

void gotoarg() : {
PostCondition node1 = null;
}
{
	entryref() ( node1=postcond() )?
	{
		System.err.println("gotoarg()");
	}
}

HaltCommand haltcommand() : {
PostCondition node1 = null;
}
{
	// deal with <HANG> also
	<HALT> ( node1=postcond() )? 
	{
// TODO: implement
		HaltCommand node = new HaltCommand(node1);
		return node;
	}
}

IfCommand ifcommand() : {}
{
	LOOKAHEAD( 3 )
	<IF> " " ifarg() ( "," ifarg() )*
	{
// TODO: implement
		IfCommand node = new IfCommand();
		return node;
	}
	| <IF> (" ")?
	{
// TODO: implement
		IfCommand node = new IfCommand();
		return node;
	}
}


void ifarg() : {System.err.println("ifarg()");}
{
	expr()
	{
		System.out.println("ifarg(1)");
	}
	| "@" expratom()
	{	
		System.out.println("ifarg(2)");
	}
}

JobCommand jobcommand() : {
PostCondition node1 = null;
}
{
	<JOB> ( node1=postcond() )? " " jobarglist()
	{
// TODO: implement
		JobCommand node = new JobCommand(node1);
		return node;
	}
}

void jobarglist() : {}
{
	jobarg() ( "," jobarg() )*
}

void jobarg() : {}
{
	"@" expratom()
	| labelref() actuallist() ( ":" jobparams() )?
	| entryref() ( ":" jobparams() )?
}

void labelref() : {}
{
	<NAME> ( "^" ( "|" environment() "|" )? )? <NAME>
	| "^" ( "|" environment() "|" )?  <NAME>
}

void environment() : {}
{
	expr()
}

void actuallist() : {}
{
	"(" exprlist() ")"
}

void jobparams() : {}
{
	( processparams() )? expr()
}

void processparams() : {}
{
	"(" ( expr() ":" )* expr() ")"
	| expr()
}

KillCommand killcommand() : {
PostCondition node1 = null;
}
{
	LOOKAHEAD( 3 )
	<KILL> ( node1=postcond() )? " " killarglist() 
	{
// TODO: implement
		KillCommand node = new KillCommand(node1);
		return node;
	}
	| <KILL> ( node1=postcond() )? (" ")*
	{
// TODO: implement
		KillCommand node2 = new KillCommand(node1);
		return node2;
	}
}

void killarglist() : {}
{
	killarg() ( "," killarg() )*
	{
	}
}

void killarg() : {}
{
	 "@" expratom()
	{
		System.out.println("killarg(1)");
	}
	| lnamelist()
	{
		System.out.println("killarg(2)");
	}
	| glvn()
	{
		System.out.println("killarg(3)");
	}
}

void lnamelist() : {}
{
	"(" ( lname() ( "," lname() )* )? ")"
	{
		System.out.println("lnamelist()");
	}
}

void lname() : {}
{
	"@" expratom() 
	{
		System.out.println("lname()");
	}
	| <NAME>
	{
		System.out.println("lname()");
	}
}

LockCommand lockcommand() : {
PostCondition node1 = null;
}
{
	<LOCK> ( node1=postcond() )? ( " " ( lockarglist() )? )?
	{
// TODO: implement
		LockCommand node = new LockCommand(node1);
		System.out.println("lockcommand()");
		return node;
	}
}

void lockarglist() : {}
{
	lockarg() ( "," lockarg() )*
}

void lockarg() : {}
{
	"@" expratom()
	| ( "+" | "-" )? ( ( "(" nreflist() ")" ) | nref() ) ( expr() )?
}

void nreflist() : {}
{
	nref() ( "," nref() )*
}

void nref() : {
	Token n1;
	Token n2;
}
{
	( "^" )? ( "|" n1=<NAME> "|" )? n2=<NAME> ( "(" exprlist() ")" )?
// | "@" expratom()  // suppressed for now because its ambiguous
}

MergeCommand mergecommand() : {
PostCondition node1 = null;
}
{
	<MERGE> ( node1=postcond() )? " " mergearglist()
	{
// TODO: implement
		MergeCommand node = new MergeCommand(node1);
		return node;
	}
}

void mergearglist() : {}
{
	mergearg() ( "," mergearg() )*
}

void mergearg() : {}
{
	"@" expratom()
	| glvn() "=" glvn() 
}

NewCommand newcommand() : {
PostCondition node1 = null;
}
{
	<NEW> ( node1=postcond() )? ( (" " newarglist()) | ( " " )? )
	{
// TODO: implement
		NewCommand node = new NewCommand(node1);
		return node;
	}
}

void newarglist() : {}
{
	newarg() ( "," newarg() )*
}

void newarg() : {}
{
	"@" expratom()
	| lnamelist() 
	| lname()
	// TODO: newsvn
}

OpenCommand opencommand() : {
PostCondition node1 = null;
}
{
	<OPEN> ( node1=postcond() )? " " openarglist()
	{
// TODO: implement
		OpenCommand node = new OpenCommand(node1);
		return node;
	}
}

void openarglist() : {}
{
	openarg() ( "," openarg() )*
}
	
void openarg() : {}
{
	"@" expratom()
	| expr() ( ":" openparameters() )?
}
	
void openparameters() : {}
{
	deviceparams() ( expr() ( ":" expr() )? )?
	| ( deviceparams() )? "::" mnemonicspec()
	| expr() ( ":" mnemonicspec() )?
}

void mnemonicspec() : {}
{
	"(" mnemonicspace() ( "," mnemonicspace() )* ")"
	| mnemonicspace()
}

void mnemonicspace() : {}
{
	expr()
}

QuitCommand quitcommand() : {
PostCondition node1 = null;
}
{
	<QUIT> ( node1=postcond() )? (" ")* ( expr() )?
	{
// TODO: implement
		QuitCommand node = new QuitCommand(node1);
		return node;
	}
}

ReadCommand readcommand() : {
PostCondition node1 = null;
}
{
	<READ> ( node1=postcond() )? " " readarglist()
	{
// TODO: implement
		ReadCommand node = new ReadCommand(node1);
		return node;
	}
}

void readarglist() : {}
{
	readarg() ( "," readarg() )*
}

void readarg() : {}
{
	"@" expratom()
	| "*" glvn() ( expr() )*
	| glvn() ( "#" expr() )? ( expr() )?
	| format()
	| <STRLIT>
}

void format() : {}  // TODO
{
	"!"
	| "#"
	| "?"
}

SetCommand setcommand() : {
	PostCondition node1 = null;
	SimpleNode node2;
}
{
	<SET> ( node1=postcond() )? " " setlist()
	{
// TODO: implement
		SetCommand node = new SetCommand(node1);
		return node;
	}
}

SimpleNode setlist() : {}
{
	"@" expratom()
	{ return jjtThis; }
	| setatom() ( "," setatom() )*
	{ return jjtThis; }
}

void setatom() : {}
{
	setdestination() "=" expr()
}

void setdestination() : {}
{
	"(" setleftlist() ")"
	| setleft()
}

void setleftlist() : {}
{
	setleft() ( "," setleft() )*
}

void setleft() : {System.err.println("setleft");}
{
	leftrestricted()
	| leftexpr()
	| glvn()
	
}

void leftrestricted() : {}
{
	<V_DEVICE>
	| <V_KEY>
	| <V_X>
	| <V_Y>
}

void leftexpr() : {}
{
	setev()
	| setextract()
	| setpiece()
}

void setev() : {}
{
	<V_ECODE>
	| <V_ETRAP>
}

void setextract() : {}
{
	<F_EXTRACT> "(" glvn() "," expr() ( "," expr() )* ")"
}

void setpiece() : {}
{
	<F_PIECE> "(" glvn() "," expr() ( "," expr() )* ( "," expr() )* ")"
}

UseCommand usecommand() : {
PostCondition node1 = null;
}
{
	<USE> ( node1=postcond() )? " " usearglist()
	{
// TODO: implement
		UseCommand node = new UseCommand(node1);
		return node;
	}
}

void usearglist() : {}
{
	usearg() ( "," usearg() )*
}

void usearg() : {}
{
	"@" expratom()
	| expr() ( ":" deviceparams() )? ( ":" mnemonicspace() )?
}

ViewCommand viewcommand() : {
PostCondition node1 = null;
}
{
	<VIEW> ( node1=postcond() )? 
	{
// TODO: implement
		ViewCommand node = new ViewCommand(node1);
		return node;
	}
}

WriteCommand writecommand() : {
PostCondition node1 = null;
}
{
	<WRITE> ( node1=postcond() )? " " writearglist()
	{
// TODO: implement
		WriteCommand node = new WriteCommand(node1);
		return node;
	}
}

void writearglist() : {}
{
	writearg() ( "," writearg() )*
}

void writearg() : {}
{
	"@" expratom()
	| "*" expr()
	| format()
	| expr()
}

XecuteCommand xecutecommand() : {
PostCondition node1 = null;
}
{
	<XECUTE> ( node1=postcond() )? " " xarglist()
	{
// TODO: implement
		XecuteCommand node = new XecuteCommand(node1);
		return node;
	}
}

void xarglist() : {}
{
	xarg() ( "," xarg() )*
}

void xarg() : {
PostCondition node1 = null;
}
{
	"@" expratom()
	| expr() ( node1=postcond() )?
}

PostCondition postcond() : {
SimpleNode node1 = null;
Expression node2 = null;
}
{
	":" node2=tvexpr()
	{ return new PostCondition(node2); }
}

Expression tvexpr() : {
Expression node1 = null;
}
{
	 node1=expr()
	{ return new Expression(); }
}

Expression expr() : {System.err.println("expr");}
{
	 expratom() (exprtail())*
	{ return new Expression(); }
}

void expratom() : {System.err.println("expratom");}
{
	glvn() 
	| expritem() 
	| "@" expratom()
}

void exprtail() : {System.err.println("exprtail");}
{
	 binaryop() expratom()
	 | ( "\'" )? relation() expratom()
	 | ( "\'" )? logicalop() expratom()
	 | ( "\'" )? "?" "."
	 | ( "\'" )? "?" "@" expratom()
}

void glvn() : {} 
{
	LOOKAHEAD( 3 )
	lvn() | gvn () | ssvn() 
}

void lvn() : {} 
{
	<NAME> ( "(" ( exprlist() )? ")" )?
	{
		System.err.println("lvn()");
	}
}

void exprlist() : {}  // TODO
{
	expr() ("," expr())* 
}

void gvn() : {}
{
	"^" lvn()
	{
		System.err.println("gvn()");
	}
}

void ssvn() : {}  // TODO
{
//	LOOKAHEAD( 2 )
    "^" <SV_CHARACTER>
	{
		System.err.println("ssvn(SV_CHARACTER)");
	}
  | "^" <F_CHAR>
	{
		System.err.println("ssvn(F_CHAR)");
	}
  | "^" <SV_DEVICE>
  | "^" <SV_GLOBAL>
  | "^" <SV_JOB>
  | "^" <SV_LOCK>
  | "^" <SV_ROUTINE>
  | "^" <V_SYSTEM>
	{
		System.err.println("ssvn(V_SYSTEM)");
	}
}

void expritem() : {}  // TODO
{
// strlit
// numlit
// exfunc
// exvar 
// svn
// function
// unaryop expratom
// ( expr )

	<NUMBER> 
       | <STRLIT>
       | unaryop() expratom()
       | "(" expr() ")"
}

void unaryop() : {}
{
	"\'" | "+" | "-"
}

void binaryop() : {}
{
	"_" | "+" | "-" | "*" | "/" | "#" | "\\" | "**"
}

void relation() : {}
{
	"=" | "<" | ">" | "]" | "[" | "]]"
}

void logicalop() : {}
{
	"&" | "!" 
}
