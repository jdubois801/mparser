
options {
	LOOKAHEAD = 2;
	STATIC = false;
}

PARSER_BEGIN(FooParser)
package com;
import java.io.StringBufferInputStream;
import com.ast.*;

public class FooParser {
	public static final String TEST_DATA = 
	"XXROUTINE ;c\r\n"+
	" ;comment\r\n"+
//	" B \r\n"+
//	" C \r\n"+
//	" Q:'(1+2!3_4+5-6*7/8#9\\10**11=12<13>14]15[16]]17&18!19+\"20\") \r\n"
//	" F \r\n"+
//	" F name=1:2 Q:0 \r\n"+
//	" K:name @name,name2,^aa,(a,b),p(3),^q(3,4),^$CHARACTER \r\n"
//	" I 1,\"false\",@foo,(1+name),p(3) \r\n"
//	" C foo \r\n"
//	" D foo \r\n"
//	" G:1 foo:0,bar:(quack+1) \r\n"
//	" H:0 \r\n"
//	" M:0 @bar,foo=^bar(12) \r\n"
//	" N foo \r\n"
	" S (foo,bar)=3,$X=2,$Y=3,$DEVICE=4,$KEY=5,$ECODE=6,$ETRAP=7,$P(foo,\"^\",3)=\"3\",$E(bar,\"^\")=9 \r\n"
//	" R foo,bar#2,*q \r\n"
//	" U foo \r\n"
//	" O foo \r\n"
//	" W:0 foo,*foo \r\n"
//	" X bob \r\n"
//	" L foo \r\n"
//	" J ^foo(1) \r\n"
	;

	public static void main(String[] args) {
		FooParser fp = new FooParser(new StringBufferInputStream(TEST_DATA));
		
		try {
			SimpleNode parseTree = fp.routine();
			// test comment
			parseTree.dump("");
			
		} catch (ParseException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		System.out.println("accept");
	}
	
	public Routine parseResult;
	
	public Routine getParseResult() {
	   return parseResult;
	}
}

PARSER_END(FooParser)



// basic commands
TOKEN : {
   < BREAK : "B"("REAK")? >
 | < CLOSE : "C"("LOSE")? >
 | < DO : "D"("O")? >
 | < ELSE : "E"("LSE")? >
 | < FOR : "F"("OR")? >
 | < GOTO : "G"("OTO")? >
 | < HALT: "H"("ALT"|"ANG")?>
 | < IF : "I"("F")? >
 | < JOB : "J"("OB")? >
 | < KILL : "K"("ILL")? >
 | < LOCK : "L"("OCK")? >
 | < MERGE : "M"("ERGE")? >
 | < NEW : "N"("EW")? >
 | < OPEN : "O"("PEN")? >
 | < QUIT : "Q"("UIT")? >
 | < READ : "R"("EAD")? >
 | < SET : "S"("ET")? >
 | < USE : "U"("SE")? >
 | < VIEW : "V"("IEW")? >
 | < WRITE : "W"("RITE")? >
 | < XECUTE : "X"("ECUTE")? >
}

// built-in functions
TOKEN : {
   < F_ASCII : "$A"("SCII")? >
 | < F_CHAR : "$C"("HAR")? >
 | < F_DATA : "$D"("ATA")? >
 | < F_EXTRACT : "$E"("XTRACT")? >
 | < F_FIND : "$F"("IND")? >
 | < F_FNUMBER : "$FN"("UMBER")? >
 | < F_GET : "$G"("ET")? >
 | < F_JUSTIFY : "$J"("USTIFY")? >
 | < F_LENGTH : "$L"("ENGTH")? >
 | < F_NAME : "$NA"("ME")? >
 | < F_ORDER : "$O"("RDER")? >
 | < F_PIECE : "$P"("IECE")? >
 | < F_QLENGTH : "$QL"("ENGTH")? >
 | < F_QSUBSCRIPT : "$QS"("UBSCRIPT")? >
 | < F_QUERY : "$Q"("UERY")? >
 | < F_RANDOM : "$R"("ANDOM")? >
 | < F_REVERSE : "$RE"("VERSE")? >
 | < F_SELECT : "$S"("ELECT")? >
 | < F_STACK : "$ST"("ACK")? >
 | < F_TEXT : "$T"("EXT")? >
 | < F_TRANSLATE : "$TR"("ANSLATE")? >
 | < F_VIEW : "$V"("IEW")? >
}

// built-in variables
TOKEN : {
    <V_DEVICE : "$D"("EVICE")? >
  | <V_ECODE : "$EC"("ODE")? >
  | <V_ESTACK : "$ES"("TACK")? >
  | <V_ETRAP : "$ET"("RAP")? >
  | <V_HORLOG : "$H"("ORLOG")? >
  | <V_IO : "$I"("O")? >
  | <V_JOB : "$J"("OB")? >
  | <V_KEY : "$K"("EY")? >
  | <V_PRINCIPAL : "$P"("RINCIPAL")? >
  | <V_QUIT : "$Q"("UIT")? >
  | <V_REFERENCE : "$R"("EFERENCE")? >
  | <V_STORAGE : "$S"("TORAGE")? >
  | <V_SYSTEM : "$SY"("STEM")? >
  | <V_TEST : "$T"("EST")? >
  | <V_X : "$X" >
  | <V_Y : "$Y" >
}

// structured system variables
TOKEN : {
    <SV_CHARACTER : "$C"("HARACTER")? >
  | <SV_GLOBAL : "$G"("LOBAL")? >
  | <SV_JOB : "$J"("OB")? >
  | <SV_LOCK : "$L"("OCK")? >
  | <SV_ROUTINE : "$R"("OUTINE")? >
//  | <SV_SYSTEM : "$S"("YSTEM")? >
  // ^$Zunspecified ??
}

// identifiers
TOKEN : {
   < NAME : ("%"|<LETTER>)(<LETTER>|<DIGIT>)* >  // not strictly correct since "%" isn't a valid name
  | <STRLIT : "\"" (["a"-"z","A"-"Z","0"-"9","^"])* "\"" > 
}

// lexical tokens
TOKEN : {
   < EOL : "\r\n" >
 | < EOR : "\r\f" >
 | < COMMENT : ";" (~["\r"])* >
 | < #LETTER : ["a"-"z","A"-"Z"] >
 | <NUMBER : (<DIGIT>)+ > 
 | < DIGIT : ["0"-"9"] >
}

SimpleNode routine() : {
Routine result = new Routine();
LineList node1 = null;
Token n1;
}
{
	n1=routinehead()
	node1=routinebody()
	{ 
		result.setName(n1==null?null:n1.toString());
		result.setLineList(node1);
		
		parseResult = result;

		return jjtThis; 
	}
}

Token routinehead() : {
Token n1;
}
{
	n1=<NAME> ( (" ")* <COMMENT>)? <EOL>
	{
		return n1;
	}
}

LineList routinebody() : {
LineList result = new LineList();
Line node1 = null;
}
{
	( node1=line() {result.add(node1);} )* ( <EOR> | <EOF> )
	{
		return result;
	}
}

Line line() : {
Line node1 = null;
}
{
	node1=levelline() 
	{ 
		return node1;
	}
	| node1=formalline() 
	{ 
		return node1;
	}
}

Line levelline() : {
CommandList node1 = null;
Line result = new Line();
Token n1 = null;
int indentation = 0;
}
{
	( n1=label() )? " " ( li() " " {indentation++;})* node1=linebody()
	{
		result.setCommandList(node1);
		result.setIndentation(indentation);
		result.setLabel(n1==null?null:n1.toString());
		return result;
	}
}

Token label() : {
Token n1;
}
{
	n1=<NAME> 
	{
		return n1;
	}
	| n1=<NUMBER>
	{
		return n1;
	}
}

void li() : {}
{
	"."
}

Line formalline() : {
Line result = new Line();
CommandList node1 = null;
Token n1;
}
{
	n1=label() formallist() (" ")+ node1=linebody()
	{
		result.setCommandList(node1);
		result.setLabel(n1==null?null:n1.toString());
		return result;
	}
}

CommandList linebody() : {
CommandList result = null;
}
{
	<COMMENT> <EOL>
	{
		return new CommandList();
	}
	| result=commandscomment() 
	{ 
		return result;
	}
	| commandsextsyntax()
	{ 
		return new CommandList(); 
	}
}

void formallist() : {}
{
	"(" (<NAME> ( formallistitem() )* )? ")"
	{
		System.out.println("formallist()");
	}
}

void formallistitem() : {
Token n1;
}
{
	"," n1=<NAME>
	{
		System.out.println("formallistitem()");
	}
}

CommandList commandscomment() : {
CommandList node1 = null;
}
{
	node1=commands() (" ")* (<COMMENT> | extsyntax())? <EOL>
	{
		return node1;
	}
}

void commandsextsyntax() : {}
{
	extsyntax() <EOL>
	{
		System.out.println("commandsextsyntax()");
	}
}

CommandList commands() : {
CommandList result = new CommandList();
Command node1 = null;
Command node2 = null;
}
{
	node1=command() {result.add(node1);} ( (" ")* node2=command() {result.add(node2);} )*
	{
		return result;
	}
}

Command command() : {
Command node1 = null;
}
{
	node1=breakcommand()
		{return node1;}
	| node1=closecommand()
		{return node1;}
	| node1=docommand()
		{return node1;}
	| node1=elsecommand()
		{return node1;}
	| node1=forcommand()
		{return node1;}
	| node1=gotocommand()
		{return node1;}
	| node1=haltcommand()
		{return node1;}
	| node1=ifcommand()
		{return node1;}
	| node1=jobcommand()
		{return node1;}
	| node1=killcommand()
		{return node1;}
	| node1=lockcommand()
		{return node1;}
	| node1=mergecommand()
		{return node1;}
	| node1=newcommand()
		{return node1;}
	| node1=opencommand()
		{return node1;}
	| node1=quitcommand()
		{return node1;}
	| node1=readcommand()
		{return node1;}
	| node1=setcommand()
		{return node1;}
	| node1=usecommand()
		{return node1;}
	| node1=viewcommand()
		{return node1;}
	| node1=writecommand()
		{return node1;}
	| node1=xecutecommand()
		{return node1;}
}

void extsyntax() : {}  // TODO
{
	"&SQL" "(" (".")* ")" 
	{
		System.out.println("extsyntax()");
	}
}

BreakCommand breakcommand() : {
PostCondition node1 = null;
}
{
	<BREAK> ( node1=postcond() )? (" ")*
	{
		return new BreakCommand(node1);
	}
}

CloseCommand closecommand() : {
PostCondition node1 = null;
ArgList node2 = null;
}
{
	<CLOSE> ( node1=postcond() )? " " node2=closearglist()
	{
// TODO: implement
		CloseCommand node = new CloseCommand(node1);
		node.setArgList(node2);
		return node;
	}
}

ArgList closearglist() : {
ArgList result = new ArgList();
}
{
	closearg() {result.add(new Arg());} ( "," closearg() {result.add(new Arg());} )*
	{
		System.err.println("closearglist()");
		return result;
	}
}

void closearg() : {}
{
	"@" expratom()
	| expr() ( ":" deviceparams() )?
}

void deviceparams() : {}
{
	"(" ( deviceparam() ( ":" deviceparam() )* )? ")"
    {
        System.err.println("deviceparams() - 2");
    }
    | deviceparam()
    {
        System.err.println("deviceparams()");
    }
}

void deviceparam() : {
Token n1;
}
{
	n1=<NAME> "=" expr()
	| n1=<NAME>
	| expr()
}

DoCommand docommand() : {
PostCondition node1 = null;
ArgList node2 = null;
}
{
	<DO> ( node1=postcond() )? ( (" " node2=doarglist() ) | (" ")? )
	{
// TODO: implement
		DoCommand node = new DoCommand(node1);
		return node;
	}
}

ArgList doarglist() : {
ArgList result = new ArgList();
}
{
	doarg() {result.add(new Arg());} ( "," doarg() {result.add(new Arg());} )*
	{
		return result;
	}
}

void doarg() : {
PostCondition node1 = null;
}
{
    // TODO - entryref and labelref are ambiguous on token <NAME>
	"@" expratom()
    | externref() ( actuallist() )? ( node1=postcond() )? 
	| entryref() ( node1=postcond() )?
	| labelref() actuallist() ( node1=postcond() )? 
}

void entryref() : {}
{
	// TODO
	"^" ( ( "|" <NAME> "|" )? <NAME> | "@" expratom() )
	{
	}
	// TODO doarg() and entryref() are ambiguous on "@foo"
	| <NAME> ( "+" <NUMBER> )?  ( "^" ( ( "|" <NAME> "|" )? <NAME> | "@" expratom() ) )?
	{
	}
}

void externref() : {}
{
    "&" ( <NAME> "." )? <NAME> ( "^" <NAME> )?
    {
    }
}

ElseCommand elsecommand() : {}
{
	<ELSE> (" ")*
	{
// have to do post processing (after parse) to figure out which indented lines
// if any are bound to this else command.
		return new ElseCommand();
	}
}

ForCommand forcommand() : {
Expression node1 = null;
Expression node2 = null;
Expression node3 = null;
}
{
	LOOKAHEAD( 3 )
	<FOR> " " lvn() "=" node1=expr() ( ":" node2=expr() )? ( ":" node3=expr() )?
	{
// TODO: implement
		ForCommand node = new ForCommand();
		node.setExpression1(node1);
		node.setExpression2(node2);
		node.setExpression3(node3);
		return node;
	}
	| <FOR> (" ")*
	{
		return new ForCommand();
	}
}

GotoCommand gotocommand() : {
PostCondition node1 = null;
ArgList node2 = null;
}
{
	<GOTO> ( node1=postcond() )? " " node2=gotoargs()
	{
// TODO: implement
		GotoCommand node = new GotoCommand(node1);
		node.setArgList(node2);
		return node;
	}
}

ArgList gotoargs() : {
ArgList result = new ArgList();
}
{
	gotoarg() {result.add(new Arg());} ( "," gotoarg() {result.add(new Arg());} )*
	{
		return result;
	}
}

void gotoarg() : {
PostCondition node1 = null;
}
{
    "@" expratom()
    {
        // TODO - return something
    }
	| entryref() ( node1=postcond() )?
	{
		System.err.println("gotoarg()");
	}
}

Command haltcommand() : {
PostCondition node1 = null;
Token n1;
Command result = null;
ArgList node2 = null;
}
{
	// deal with <HANG> also
	n1=<HALT> ( node1=postcond() )? " " ( node2=hangarglist() )?
	{
		if ("HANG".equals(n1.toString())) {  System.err.println("HANG!");
			result = new HangCommand();
		}
		else if (node2 != null) { System.err.println("node2 != null");
            result = new HangCommand();
		}
		else { System.err.println("HALT node2 == null");
			result = new HaltCommand(node1);
		}
        result.setPostCondition(node1);
		return result;
	}
}

ArgList hangarglist() : {
ArgList node1 = new ArgList();
Token n1;
Token n2;
}
{
    hangarg() ( "," hangarg() )*
    {
        return node1;
    }
}

void hangarg() : {
Token n1;
}
{
    "@" expratom()
    | n1=<NUMBER>
}
    
IfCommand ifcommand() : {
ArgList node1 = new ArgList();
}
{
	LOOKAHEAD( 3 )
	<IF> " " ifarg() ( "," ifarg() )*
	{
// TODO: implement
		IfCommand node = new IfCommand();
		node.setArgList(node1);
		return node;
	}
	| <IF> (" ")?
	{
// we'll have to do some post processing after parse to figure out
// which indented lines belong to this if command.
		return new IfCommand();
	}
}


void ifarg() : {System.err.println("ifarg()");}
{
	expr()
	{
		System.out.println("ifarg(1)");
	}
	| "@" expratom()
	{	
		System.out.println("ifarg(2)");
	}
}

JobCommand jobcommand() : {
PostCondition node1 = null;
ArgList node2 = null;
}
{
	<JOB> ( node1=postcond() )? " " node2=jobarglist()
	{
		JobCommand node = new JobCommand(node1);
		node.setArgList(node2);
		return node;
	}
}

ArgList jobarglist() : {
ArgList result = new ArgList();
Arg node1 = null;
Arg node2 = null;
}
{
	node1=jobarg() {result.add(node1);} ( "," node2=jobarg() {result.add(node2);} )*
	{
		return result;
	}
}

Arg jobarg() : {
Arg result = new Arg();
}
{
	"@" expratom()
	{
	   return result;
	}
    | entryref() ( ":" jobparams() )?
    {
       return result;
    }
	| labelref() actuallist() ( ":" jobparams() )?
    {
       return result;
    }
}

void labelref() : {}
{
	<NAME> (( "^" ( "|" environment() "|" )? ) | " ") <NAME>
	| "^" ( "|" environment() "|" )?  <NAME>
}

void environment() : {}
{
	expr()
}

void actuallist() : {}
{
	"(" ( actualorexprlist() )? ")"
}

void actualorexprlist() : {}
{
    actualorexpr() ( "," actualorexpr() )*
}

void actualorexpr() : {}
{
    "." <NAME>
    | expr()
}

void jobparams() : {}
{
	( processparams() " " )? expr()
}

void processparams() : {}
{
	"(" ( expr() ":" )* expr() ")"
	| expr()
}

KillCommand killcommand() : {
PostCondition node1 = null;
ArgList node2 = null;
}
{
	LOOKAHEAD( 3 )
	<KILL> ( node1=postcond() )? " " node2=killarglist() 
	{
// TODO: implement
		KillCommand node = new KillCommand(node1);
		node.setArgList(node2);
		return node;
	}
	| <KILL> ( node1=postcond() )? (" ")*
	{
// TODO: implement
		KillCommand node3 = new KillCommand(node1);
		return node3;
	}
}

ArgList killarglist() : {
ArgList result = new ArgList();
}
{
	killarg() {result.add(new Arg());} ( "," killarg() {result.add(new Arg());} )*
	{
		return result;
	}
}

void killarg() : {}
{
	 "@" expratom()
	{
		System.out.println("killarg(1)");
	}
	| lnamelist()
	{
		System.out.println("killarg(2)");
	}
	| glvn()
	{
		System.out.println("killarg(3)");
	}
}

void lnamelist() : {}
{
	"(" ( lname() ( "," lname() )* )? ")"
	{
		System.out.println("lnamelist()");
	}
}

void lname() : {}
{
	"@" expratom() 
	{
		System.out.println("lname()");
	}
	| <NAME>
	{
		System.out.println("lname()");
	}
}

LockCommand lockcommand() : {
PostCondition node1 = null;
ArgList node2 = null;
}
{
	<LOCK> ( node1=postcond() )? ( " " ( node2=lockargparens() )? )?
	{
		LockCommand node = new LockCommand(node1);
		node.setArgList(node2);
		return node;
	}
}

ArgList lockargparens() : {
ArgList result = null;
}
{
    "(" ( result=lockarglist() )? ")"
    {
        if (result == null) {
            result = new ArgList();
        }
        
        return result;
    }
    |
    result = lockarglist()
    {
        return result;
    }
}

ArgList lockarglist() : {
ArgList result = new ArgList();
}
{
	lockarg() {result.add(new Arg());} ( "," lockarg() {result.add(new Arg());} )*
	{
		return result;
	}
	// TODO - the grammar is ambiguous here. there is also the possibility of a @expratom interpreted as a lock arg list
	// but that is ambiguous with a @expratom interpreted as a nref.
	|  "@" expratom()
	{
	   result.setLiveArg("expratom");  // TODO - get the correct value here.
	   return result;
	}
}

void lockarg() : {
Token n1;
Expression node2 = null;
}
{
	( n1="+" | n1="-" )? ( ( "(" nreflist() ")" ) | nref() ) ( " " node2=expr() )?
}

void nreflist() : {}
{
	nref() ( "," nref() )*
}

void nref() : {
	Token n1;
	Token n2;
}
{
	( "^" )? ( "|" n1=<NAME> "|" )? n2=<NAME> ( "(" exprlist() ")" )?
// | "@" expratom()  // suppressed for now because its ambiguous
}

MergeCommand mergecommand() : {
PostCondition node1 = null;
ArgList node2 = null;
}
{
	<MERGE> ( node1=postcond() )? " " node2=mergearglist()
	{
// TODO: implement
		MergeCommand node = new MergeCommand(node1);
		node.setArgList(node2);
		return node;
	}
}

ArgList mergearglist() : {
ArgList result = new ArgList();
}
{
	mergearg() {result.add(new Arg());} ( "," mergearg() {result.add(new Arg());} )*
	{
		return result;
	}
}

void mergearg() : {}
{
	"@" expratom()
	| glvn() "=" glvn() 
}

NewCommand newcommand() : {
PostCondition node1 = null;
ArgList node2 = null;
}
{
	<NEW> ( node1=postcond() )? ( (" " node2=newarglist()) | ( " " )? )
	{
// TODO: implement
		NewCommand node = new NewCommand(node1);
		node.setArgList(node2);
		return node;
	}
}

ArgList newarglist() : {
ArgList result = new ArgList();
}
{
	newarg() {result.add(new Arg());} ( "," newarg() {result.add(new Arg());} )*
	{
		return result;
	}
}

void newarg() : {}
{
	"@" expratom()
	| lnamelist() 
	| lname()
	// TODO: newsvn
}

OpenCommand opencommand() : {
PostCondition node1 = null;
ArgList node2 = null;
}
{
	<OPEN> ( node1=postcond() )? " " node2=openarglist()
	{
// TODO: implement
		OpenCommand node = new OpenCommand(node1);
		node.setArgList(node2);
		return node;
	}
}

ArgList openarglist() : {
ArgList result = new ArgList();
}
{
	openarg() {result.add(new Arg());} ( "," openarg() {result.add(new Arg());} )*
	{
		return result;
	}
}
	
void openarg() : {}
{
	"@" expratom()
	| expr() ( ":" openparameters() )?
}
	
void openparameters() : {}
{
    // TODO - the grammar is ambiguous around deviceparams() = expr() and expr()
	deviceparams() ( expr() ( ":" expr() )? )?
	| ( deviceparams() )? "::" mnemonicspec()
	| expr() ( ":" mnemonicspec() )?
}

void mnemonicspec() : {}
{
	"(" mnemonicspace() ( "," mnemonicspace() )* ")"
	| mnemonicspace()
}

void mnemonicspace() : {}
{
	expr()
}

QuitCommand quitcommand() : {
PostCondition node1 = null;
Expression node2 = null;
}
{
	<QUIT> ( node1=postcond() )? (" ")* ( node2=expr() )?
	{
// TODO: implement
		QuitCommand node = new QuitCommand(node1);
		node.setReturnExpression(node2);
		return node;
	}
}

ReadCommand readcommand() : {
PostCondition node1 = null;
ArgList node2 = null;
}
{
	<READ> ( node1=postcond() )? " " node2=readarglist()
	{
// TODO: implement
		ReadCommand node = new ReadCommand(node1);
		node.setArgList(node2);
		return node;
	}
}

ArgList readarglist() : {
ArgList result = new ArgList();
}
{
	readarg() {result.add(new Arg());} ( "," readarg() {result.add(new Arg());} )*
	{
		return result;
	}
}

void readarg() : {}
{
	"@" expratom()
	| "*" glvn() ( " " expr() )?
	| glvn() ( "#" expr() )? ( " " expr() )?
	| ( format() )+
	| <STRLIT>
}

void format() : {}  // TODO
{
	"!"
	| "#"
	| "?"
}

SetCommand setcommand() : {
	PostCondition node1 = null;
	ArgList node2 = null;
}
{
	<SET> ( node1=postcond() )? " " node2=setlist()
	{
		SetCommand node = new SetCommand(node1);
		node.setArgList(node2);
		return node;
	}
}

ArgList setlist() : {
ArgList result = new ArgList();
Arg node1 = null;
Arg node2 = null;
}
{
	node1=setatom() {result.add(node1);} ( "," node2=setatom() {result.add(node2);} )*
	{ 
	   return result; 
	}
}

Arg setatom() : {
Arg result = new Arg();
}
{
    "@" expratom()
    {
        return result;
    }
	| setdestination() "=" expr()
	{
	   return result;
	}
}

void setdestination() : {}
{
	"(" setleftlist() ")"
	| setleft()
}

void setleftlist() : {}
{
	setleft() ( "," setleft() )*
}

void setleft() : {System.err.println("setleft");}
{
	leftrestricted()
	| leftexpr()
	| glvn()
	
}

void leftrestricted() : {}
{
	( <V_DEVICE> | <F_DATA> )  // TODO - need to throw an exception on "$DATA" which does not match
	| <V_KEY>
	| <V_X>
	| <V_Y>
}

void leftexpr() : {}
{
	setev()
	| setextract()
	| setpiece()
}

void setev() : {}
{
	<V_ECODE>
	| <V_ETRAP>
}

void setextract() : {}
{
	<F_EXTRACT> "(" glvn() "," expr() ( "," expr() )? ")"
}

void setpiece() : {}
{
	<F_PIECE> "(" glvn() "," expr() ( "," expr() )? ( "," expr() )? ")"
}

UseCommand usecommand() : {
PostCondition node1 = null;
ArgList node2 = null;
}
{
	<USE> ( node1=postcond() )? " " node2=usearglist()
	{
// TODO: implement
		UseCommand node = new UseCommand(node1);
		node.setArgList(node2);
		return node;
	}
}

ArgList usearglist() : {
ArgList result = new ArgList();
Arg node1 = null;
Arg node2 = null;
}
{
	node1=usearg() {result.add(node1);} ( "," node2=usearg() {result.add(node2);} )*
	{
		return result;
	}
}

Arg usearg() : {
Arg result = new Arg();
}
{
	"@" expratom()
	{
	   return result;
	}
	| expr() ( ":" deviceparams() )? ( ":" mnemonicspace() )?
	{
	   return result;
	}
}

ViewCommand viewcommand() : {
PostCondition node1 = null;
}
{
	<VIEW> ( node1=postcond() )? 
	{
// TODO: implement
		ViewCommand node = new ViewCommand(node1);
		return node;
	}
}

WriteCommand writecommand() : {
PostCondition node1 = null;
ArgList node2 = null;
}
{
	<WRITE> ( node1=postcond() )? " " node2=writearglist()
	{
// TODO: implement
		WriteCommand node = new WriteCommand(node1);
		node.setArgList(node2);
		return node;
	}
}

ArgList writearglist() : {
ArgList result = new ArgList();
Arg node1 = null;
Arg node2 = null;
}
{
	node1=writearg() {result.add(node1);} ( "," node2=writearg() {result.add(node2);} )*
	{
		return result;
	}
}

Arg writearg() : {
Arg result = new Arg();
}
{
	"@" expratom()
	{
	   return result;
	}
	| "*" expr()
	{
	   return result;
	}
	| ( format() )+
	{
	   return result;
	}
	| expr()
	{
	   return result;
	}
}

XecuteCommand xecutecommand() : {
PostCondition node1 = null;
ArgList node2 = null;
}
{
	<XECUTE> ( node1=postcond() )? " " node2=xarglist()
	{
// TODO: implement
		XecuteCommand node = new XecuteCommand(node1);
		node.setArgList(node2);
		return node;
	}
}

ArgList xarglist() : {
ArgList result = new ArgList();
}
{
	xarg() {result.add(new Arg());} ( "," xarg() {result.add(new Arg());} )*
	{
		return result;
	}
}

void xarg() : {
PostCondition node1 = null;
}
{
	"@" expratom()
	| expr() ( node1=postcond() )?
}

PostCondition postcond() : {
SimpleNode node1 = null;
Expression node2 = null;
}
{
	":" node2=tvexpr()
	{ return new PostCondition(node2); }
}

Expression tvexpr() : {
Expression node1 = null;
}
{
	 node1=expr()
	{ return new Expression(); }
}

Expression expr() : {System.err.println("expr");}
{
	 expratom() (exprtail())*
	{ return new Expression(); }
}

void expratom() : {System.err.println("expratom");}
{
	glvn() 
	| expritem() 
	| "@" expratom()
}

void exprtail() : {System.err.println("exprtail");}
{
	 binaryop() expratom()
	 | ( "\'" )? relation() expratom()
	 | ( "\'" )? logicalop() expratom()
	 | ( "\'" )? "?" "."
	 | ( "\'" )? "?" "@" expratom()
}

void glvn() : {} 
{
	LOOKAHEAD( 3 )
	lvn() | gvn () | ssvn() 
}

void lvn() : {} 
{
	<NAME> ( "(" ( exprlist() )? ")" )?
	{
		System.err.println("lvn()");
	}
}

void exprlist() : {}  // TODO
{
	expr() ("," expr())* 
}

void gvn() : {}
{
	"^" lvn()
	{
		System.err.println("gvn()");
	}
}

void ssvn() : {}  // TODO
{
//	LOOKAHEAD( 2 )
    "^" <SV_CHARACTER>
	{
		System.err.println("ssvn(SV_CHARACTER)");
	}
  | "^" <F_CHAR>
	{
		System.err.println("ssvn(F_CHAR)");
	}
  | "^" <V_DEVICE>
  | "^" <SV_GLOBAL>
  | "^" <SV_JOB>
  | "^" <SV_LOCK>
  | "^" <SV_ROUTINE>
  | "^" <V_SYSTEM>
	{
		System.err.println("ssvn(V_SYSTEM)");
	}
}

void expritem() : {}  // TODO
{
// strlit
// numlit
// exfunc
// exvar 
// svn
// function
// unaryop expratom
// ( expr )

	<NUMBER> 
       | <STRLIT>
       | unaryop() expratom()
       | "(" expr() ")"
}

void unaryop() : {}
{
	"\'" | "+" | "-"
}

void binaryop() : {}
{
	"_" | "+" | "-" | "*" | "/" | "#" | "\\" | "**"
}

void relation() : {}
{
	"=" | "<" | ">" | "]" | "[" | "]]"
}

void logicalop() : {}
{
	"&" | "!" 
}
