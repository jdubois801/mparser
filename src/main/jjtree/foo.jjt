
options {
	LOOKAHEAD = 2;
	STATIC = false;
}

PARSER_BEGIN(FooParser)
package com;
import java.io.StringBufferInputStream;
import com.ast.*;
import com.ast.command.*;
import com.ast.expression.*;

public class FooParser {
	public static final String TEST_DATA = 
	"XXROUTINE ;c\r\n"+
	" ;comment\r\n"+
//	" B \r\n"+
//	" C \r\n"+
//	" Q:'(1+2!3_4+5-6*7/8#9\\10**11=12<13>14]15[16]]17&18!19+\"20\") \r\n"
//	" F \r\n"+
//	" F name=1:2 Q:0 \r\n"+
//	" K:name @name,name2,^aa,(a,b),p(3),^q(3,4),^$CHARACTER \r\n"
//	" I 1,\"false\",@foo,(1+name),p(3) \r\n"
//	" C foo \r\n"
//	" D foo \r\n"
//	" G:1 foo:0,bar:(quack+1) \r\n"
//	" H:0 \r\n"
//	" M:0 @bar,foo=^bar(12) \r\n"
//	" N foo \r\n"
	" S (foo,bar)=3,$X=2,$Y=3,$DEVICE=4,$KEY=5,$ECODE=6,$ETRAP=7,$P(foo,\"^\",3)=\"3\",$E(bar,\"^\")=9 \r\n"
//	" R foo,bar#2,*q \r\n"
//	" U foo \r\n"
//	" O foo \r\n"
//	" W:0 foo,*foo \r\n"
//	" X bob \r\n"
//	" L foo \r\n"
//	" J ^foo(1) \r\n"
	;

	public static void main(String[] args) {
		FooParser fp = new FooParser(new StringBufferInputStream(TEST_DATA));
		
		try {
			SimpleNode parseTree = fp.routine();
			// test comment
			parseTree.dump("");
			
		} catch (ParseException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		System.out.println("accept");
	}
	
	public Routine parseResult;
	
	public Routine getParseResult() {
	   return parseResult;
	}
	
	
    public Expression leftRightBind(Expression leftExpr, Expression rightExpr)
    {
        Expression result = leftExpr;
        
        if (rightExpr instanceof BinaryExpression) {
            ((BinaryExpression)rightExpr).setLeftExpression(leftExpr);
            result = rightExpr;
        }
        else if (rightExpr instanceof LogicalExpression) {
            ((LogicalExpression)rightExpr).setLeftExpression(leftExpr);
            result = rightExpr;
        }
        else if (rightExpr instanceof RelationExpression) {
            ((RelationExpression)rightExpr).setLeftExpression(leftExpr);
            result = rightExpr;
        }
        else if (rightExpr instanceof MatchExpression) {
            ((MatchExpression)rightExpr).setLeftExpression(leftExpr);
            result = rightExpr;
        }
        
        return result;
    }
	
}

PARSER_END(FooParser)


// sql syntax
TOKEN : {
   < SQL : "&SQL(" (~["\n","\r"])* >
}

// basic commands
TOKEN : {
   < BREAK : "B"("REAK")? >
 | < CLOSE : "C"("LOSE")? >
 | < DO : "D"("O")? >
 | < ELSE : "E"("LSE")? >
 | < FOR : "F"("OR")? >
 | < GOTO : "G"("OTO")? >
 | < HALT: "H"("ALT"|"ANG")?>
 | < IF : "I"("F")? >
 | < JOB : "J"("OB")? >
 | < KILL : "K"("ILL")? >
 | < LOCK : "L"("OCK")? >
 | < MERGE : "M"("ERGE")? >
 | < NEW : "N"("EW")? >
 | < OPEN : "O"("PEN")? >
 | < QUIT : "Q"("UIT")? >
 | < READ : "R"("EAD")? >
 | < SET : "S"("ET")? >
 | < USE : "U"("SE")? >
 | < VIEW : "V"("IEW")? >
 | < WRITE : "W"("RITE")? >
 | < XECUTE : "X"("ECUTE")? >
}

// built-in functions
TOKEN : {
   < F_ASCII : "$A"("SCII")? >
 | < F_CHAR : "$C"("HAR")? >
 | < F_DATA : "$D"("ATA")? >
 | < F_EXTRACT : "$E"("XTRACT")? >
 | < F_FIND : "$F"("IND")? >
 | < F_FNUMBER : "$FN"("UMBER")? >
 | < F_GET : "$G"("ET")? >
 | < F_JUSTIFY : "$J"("USTIFY")? >
 | < F_LENGTH : "$L"("ENGTH")? >
 | < F_NAME : "$NA"("ME")? >
 | < F_ORDER : "$O"("RDER")? >
 | < F_PIECE : "$P"("IECE")? >
 | < F_QLENGTH : "$QL"("ENGTH")? >
 | < F_QSUBSCRIPT : "$QS"("UBSCRIPT")? >
 | < F_QUERY : "$Q"("UERY")? >
 | < F_RANDOM : "$R"("ANDOM")? >
 | < F_REVERSE : "$RE"("VERSE")? >
 | < F_SELECT : "$S"("ELECT")? >
 | < F_STACK : "$ST"("ACK")? >
 | < F_TEXT : "$T"("EXT")? >
 | < F_TRANSLATE : "$TR"("ANSLATE")? >
 | < F_VIEW : "$V"("IEW")? >
}

// built-in variables
TOKEN : {
    <V_DEVICE : "$D"("EVICE")? >
  | <V_ECODE : "$EC"("ODE")? >
  | <V_ESTACK : "$ES"("TACK")? >
  | <V_ETRAP : "$ET"("RAP")? >
  | <V_HORLOG : "$H"("ORLOG")? >
  | <V_IO : "$I"("O")? >
  | <V_JOB : "$J"("OB")? >
  | <V_KEY : "$K"("EY")? >
  | <V_PRINCIPAL : "$P"("RINCIPAL")? >
  | <V_QUIT : "$Q"("UIT")? >
  | <V_REFERENCE : "$R"("EFERENCE")? >
  | <V_STORAGE : "$S"("TORAGE")? >
  | <V_SYSTEM : "$SY"("STEM")? >
  | <V_TEST : "$T"("EST")? >
  | <V_X : "$X" >
  | <V_Y : "$Y" >
}

// structured system variables
TOKEN : {
    <SV_CHARACTER : "$C"("HARACTER")? >
  | <SV_GLOBAL : "$G"("LOBAL")? >
//  | <SV_JOB : "$J"("OB")? >
  | <SV_LOCK : "$L"("OCK")? >
  | <SV_ROUTINE : "$R"("OUTINE")? >
//  | <SV_SYSTEM : "$S"("YSTEM")? >
  // ^$Zunspecified ??
}

// identifiers
TOKEN : {
   < NAME : ("%"|<LETTER>)(<LETTER>|<DIGIT>)* >  // not strictly correct since "%" isn't a valid name
  | <STRLIT : "\"" (["a"-"z","A"-"Z","0"-"9","^"])* "\"" > 
}

// lexical tokens
TOKEN : {
   < EOL : "\r\n" >
 | < EOR : "\r\f" >
 | < COMMENT : ";" (~["\r"])* >
 | < #LETTER : ["a"-"z","A"-"Z"] >
 | <NUMBER : (<DIGIT>)+ > 
 | < DIGIT : ["0"-"9"] >
}

SimpleNode routine() : {
Routine result = new Routine();
LineList node1 = null;
Token n1;
}
{
	n1=routinehead()
	node1=routinebody()
	{ 
		result.setName(n1==null?null:n1.toString());
		result.setLineList(node1);
		
		parseResult = result;

		return jjtThis; 
	}
}

Token routinehead() : {
Token n1;
}
{
	n1=<NAME> ( (" ")* <COMMENT>)? <EOL>
	{
		return n1;
	}
}

LineList routinebody() : {
LineList result = new LineList();
Line node1 = null;
}
{
	( node1=line() {result.add(node1);} )* ( <EOR> | <EOF> )
	{
		return result;
	}
}

Line line() : {
Line node1 = null;
}
{
	node1=levelline() 
	{ 
		return node1;
	}
	| node1=formalline() 
	{ 
		return node1;
	}
}

Line levelline() : {
CommandList node1 = null;
Line result = null;
Token n1 = null;
int indentation = 0;
}
{
	( n1=label() )? " " ( ". " {indentation++;})* node1=linebody()
	{
	    if (n1 != null) {
	       result = new LabelLine(n1.toString());
	    }
	    else {
	       result = new Line();
	    }
		result.setCommandList(node1);
		result.setIndentation(indentation);
		return result;
	}
}

Token label() : {
Token n1;
}
{
	n1=<NAME> 
	{
		return n1;
	}
	| n1=<NUMBER>
	{
		return n1;
	}
}

Line formalline() : {
FormalLine result = null;
CommandList node1 = null;
ParamList paramlist = null;
Token n1;
}
{
	n1=label() paramlist = formallist() (" ")+ node1=linebody()
	{
	    result = new FormalLine(n1.toString());
	    result.setParamList(paramlist);
		result.setCommandList(node1);
		result.setLabel(n1==null ? null : n1.toString());
		return result;
	}
}

CommandList linebody() : {
CommandList result = null;
}
{
	<COMMENT> <EOL>
	{
		return new CommandList();
	}
	| result=commandscomment() 
	{ 
		return result;
	}
	| result=commandsextsyntax()
	{ 
		return result; 
	}
}

ParamList formallist() : {
ParamList result = new ParamList();
Token n1 = null;
Token n2 = null;
}
{
	"(" (n1=<NAME> {result.add(new Param(n1.toString()));}  ( "," n2=<NAME> {result.add(new Param(n2.toString()));} )* )? ")"
	{
		return result;
	}
}

CommandList commandscomment() : {
CommandList result = null;
Expression ext = null;
}
{
	result=commands() (" ")* ( <COMMENT> | ext=extsyntax() )? <EOL>
	{
	    if (ext != null) {
            result.setExtSyntax(ext);	           
	    }
	    return result;
	}
}

CommandList commandsextsyntax() : {
CommandList result = new CommandList();
Expression ext = null;
}
{
	ext=extsyntax() <EOL>
	{
        if (ext != null) {
            result.setExtSyntax(ext);              
        }
		return result;
	}
}

CommandList commands() : {
CommandList result = new CommandList();
Command node1 = null;
Command node2 = null;
}
{
	node1=command() {result.add(node1);} ( (" ")* node2=command() {result.add(node2);} )*
	{
		return result;
	}
}

Command command() : {
Command node1 = null;
}
{
	node1=breakcommand()
		{return node1;}
	| node1=closecommand()
		{return node1;}
	| node1=docommand()
		{return node1;}
	| node1=elsecommand()
		{return node1;}
	| node1=forcommand()
		{return node1;}
	| node1=gotocommand()
		{return node1;}
	| node1=haltcommand()
		{return node1;}
	| node1=ifcommand()
		{return node1;}
	| node1=jobcommand()
		{return node1;}
	| node1=killcommand()
		{return node1;}
	| node1=lockcommand()
		{return node1;}
	| node1=mergecommand()
		{return node1;}
	| node1=newcommand()
		{return node1;}
	| node1=opencommand()
		{return node1;}
	| node1=quitcommand()
		{return node1;}
	| node1=readcommand()
		{return node1;}
	| node1=setcommand()
		{return node1;}
	| node1=usecommand()
		{return node1;}
	| node1=viewcommand()
		{return node1;}
	| node1=writecommand()
		{return node1;}
	| node1=xecutecommand()
		{return node1;}
}

ExtSyntaxConstant extsyntax() : {
ExtSyntaxConstant result = null;
Token n1 = null;
}
{
	n1=<SQL> 
	{ 
	    String txt = n1.toString();
	    result = new ExtSyntaxConstant(txt.substring(5, txt.length()-1));
	    return result;
	}
}

BreakCommand breakcommand() : {
PostCondition node1 = null;
}
{
	<BREAK> ( node1=postcond() )? (" ")*
	{
		return new BreakCommand(node1);
	}
}

CloseCommand closecommand() : {
PostCondition node1 = null;
ArgList node2 = null;
}
{
	<CLOSE> ( node1=postcond() )? " " node2=closearglist()
	{
		CloseCommand result = new CloseCommand(node1);
		result.setArgList(node2);
		return result;
	}
}

ArgList closearglist() : {
ArgList result = new ArgList();
Arg node1 = null;
Arg node2 = null;
}
{
	node1=closearg() {result.add(node1);} ( "," node2=closearg() {result.add(node2);} )*
	{
		return result;
	}
}

Arg closearg() : {
CloseArg result = new CloseArg();
Expression node1 = null;
DeviceParamList node2 = null;
}
{
	"@" node1=expratom()
	{
	   result.setExpression(new IndirectExpression(node1));
	   return result;
	}
	| node1=expr() ( ":" node2=deviceparams() )?
	{
	   result.setExpression(node1);
	   result.setDeviceParamList(node2);
	   return result;
	}
}

DeviceParamList deviceparams() : {
DeviceParamList result = new DeviceParamList();
DeviceParam node1 = null;
DeviceParam node2 = null;
}
{
	"(" ( node1=deviceparam() {result.add(node1);} ( ":" node2=deviceparam() {result.add(node2);} )* )? ")"
    {
        return result;
    }
    | node1=deviceparam()
    {
        result.add(node1);
        return result;
    }
}

DeviceParam deviceparam() : {
DeviceParam result = new DeviceParam();
Token n1;
Expression node2 = null;
}
{
	n1=<NAME> "=" node2=expr()
	{
        result.setName(n1.toString());
        result.setExpression(node2);
	    return result;
	}
	| n1=<NAME>
    {
        result.setName(n1.toString());
        return result;
    }
	| node2=expr()
    { 
        result.setExpression(node2);
        return result;
    }
}

DoCommand docommand() : {
PostCondition node1 = null;
ArgList node2 = null;
}
{
	<DO> ( node1=postcond() )? ( (" " node2=doarglist() ) | (" ")? )
	{
		DoCommand node = new DoCommand(node1);
		node.setArgList(node2);
		return node;
	}
}

ArgList doarglist() : {
ArgList result = new ArgList();
Arg node1 = null;
Arg node2 = null;
}
{
	node1=doarg() {result.add(node1);} ( "," node2=doarg() {result.add(node2);} )*
	{
		return result;
	}
}

Arg doarg() : {
Arg result = new Arg();
Expression node2 = null;
PostCondition node1 = null;
ArgList node3 = null;
}
{
    // TODO - entryref and labelref are ambiguous on token <NAME>
	"@" node2=expratom()
	{
	   result.setExpression(node2);
	   return result;
	}
    | node2=externref() ( node3=actuallist() )? ( node1=postcond() )? 
    {
        if (node1 != null) {
            ConditionalArg condArg = new ConditionalArg();
            condArg.setCondition(node1.getExpr());
            condArg.setExpression(node2);
            ((ExternRef)node2).setArgList(node3);
            return condArg;
        }
        ((ExternRef)node2).setArgList(node3);
        result.setExpression(node2);
        return result;
    }
	| node2=entryref() ( node3=actuallist() )? ( node1=postcond() )?
    {
        if (node1 != null) {
            ConditionalArg condArg = new ConditionalArg();
            condArg.setCondition(node1.getExpr());
            
            condArg.setExpression(node2);
            if (node3 != null) {
                LabelRef lref = LabelRef.from((EntryRef)node2);
                lref.setArgList(node3);
                // it's a label ref, not an entry ref.
                condArg.setExpression(lref);
            }
            
            return condArg;
        }
        result.setExpression(node2);
        
        if (node3 != null) {
            LabelRef lref = LabelRef.from((EntryRef)node2);
            lref.setArgList(node3);
            // it's a label ref, not an entry ref.
            result.setExpression(lref);
        }
        
        return result;
    }
}

Expression entryref() : {
EntryRef result = new EntryRef();
Expression indexpr = null;
Expression node3 = null;
Token n1 = null;
Token n2 = null;
Token n3 = null;
Token n4 = null;
}
{
	// TODO
	"^" ( ( "|" node3=expr() "|" )? n4=<NAME> | "@" indexpr=expratom() )
	{
        if (n3 != null) {
           result.setEnvironment(node3);
        }
        if (n4 != null) {
           result.setRoutine(n4.toString());
        }
        if (indexpr != null) {
            result.setIndirectExpression(new IndirectExpression(indexpr));
        }        
	    return result;
	}
	// TODO doarg() and entryref() are ambiguous on "@foo"
	| n1=<NAME> ( "+" n2=<NUMBER> )?  ( "^" ( ( "|" node3=expr() "|" )? n4=<NAME> | "@" indexpr=expratom() ) )?
	{
	    result.setName(n1.toString());
	    if (n2 != null) {
	       result.setOffset(n2.toString());
	    }
        if (n3 != null) {
           result.setEnvironment(node3);
        }
        if (n4 != null) {
           result.setRoutine(n4.toString());
        }
        if (indexpr != null) {
            result.setIndirectExpression(new IndirectExpression(indexpr));
        }        
	    return result;
	}
}

Expression externref() : {
ExternRef result = new ExternRef();
Token n1 = null;
Token n2 = null;
Token n3 = null;

}
{
    "&" ( n1=<NAME> "." )? n2=<NAME> ( "^" n3=<NAME> )?
    {
        if (n1 != null) {
            result.setPackageName(n1.toString());
        }
        if (n3 != null) {
            result.setRoutine(n3.toString());
            result.setLabel(n2.toString());
        }
        result.setLabel(n2.toString());
        return result;
    }
}

ElseCommand elsecommand() : {}
{
	<ELSE> (" ")*
	{
// have to do post processing (after parse) to figure out which indented lines
// if any are bound to this else command.
		return new ElseCommand();
	}
}

ForCommand forcommand() : {
Expression dest = null;
Expression node1 = null;
Expression node2 = null;
Expression node3 = null;
}
{
	LOOKAHEAD( 3 )
	<FOR> " " dest=lvn() "=" node1=expr() ( ":" node2=expr() )? ( ":" node3=expr() )?
	{
// TODO: implement
		ForCommand node = new ForCommand();
		node.setDestination(dest);
		node.setExpression1(node1);
		node.setExpression2(node2);
		node.setExpression3(node3);
		return node;
	}
	| <FOR> (" ")*
	{
		return new ForCommand();
	}
}

GotoCommand gotocommand() : {
PostCondition node1 = null;
ArgList node2 = null;
}
{
	<GOTO> ( node1=postcond() )? " " node2=gotoargs()
	{
		GotoCommand node = new GotoCommand(node1);
		node.setArgList(node2);
		return node;
	}
}

ArgList gotoargs() : {
ArgList result = new ArgList();
Arg node1 = null;
Arg node2 = null;
}
{
	node1=gotoarg() {result.add(node1);} ( "," node2=gotoarg() {result.add(node2);} )*
	{
		return result;
	}
}

Arg gotoarg() : {
Arg result = new Arg();
PostCondition node1 = null;
Expression node2 = null;
}
{
    "@" node2=expratom()
    {
       result.setExpression(new IndirectExpression(node2));
       return result;
    }
	| node2=entryref() ( node1=postcond() )?
	{
	   if (node1 != null) {
	       result = new ConditionalArg();
	       ((ConditionalArg)result).setCondition(node1.getExpr()); 
	   }
	   result.setExpression(node2);
	   return result;
	}
}

Command haltcommand() : {
PostCondition node1 = null;
Token n1;
Command result = null;
ArgList node2 = null;
}
{
	// deal with <HANG> also
	n1=<HALT> ( node1=postcond() )? " " ( node2=hangarglist() )?
	{
		if ("HANG".equals(n1.toString())) {
			result = new HangCommand();
		}
		else if (node2 != null) {
            result = new HangCommand();
            ((HangCommand)result).setArgList(node2);
		}
		else {
			result = new HaltCommand(node1);
		}
        result.setPostCondition(node1);
		return result;
	}
}

ArgList hangarglist() : {
ArgList result = new ArgList();
Arg node1 = null;
Arg node2 = null;
Token n1;
Token n2;
}
{
    node1=hangarg() {result.add(node1);} ( "," node2=hangarg() {result.add(node2);} )*
    {
        return result;
    }
}

Arg hangarg() : {
Arg result = new Arg();
Expression node1 = null;
Token n1;
}
{
    "@" node1=expratom()
    {
        result.setExpression(new IndirectExpression(node1));
        return result;
    }
    | n1=<NUMBER>
    {
        result.setExpression(new NumericConstant(n1.toString()));
        return result;
    }
}
    
IfCommand ifcommand() : {
ArgList arglist = new ArgList();
Arg node1 = null;
Arg node2 = null;
}
{
	LOOKAHEAD( 3 )
	<IF> " " node1=ifarg() {arglist.add(node1);} ( "," node2=ifarg() {arglist.add(node2);} )*
	{
		IfCommand node = new IfCommand();
		node.setArgList(arglist);
		return node;
	}
	| <IF> (" ")?
	{
// we'll have to do some post processing after parse to figure out
// which indented lines belong to this if command.
		return new IfCommand();
	}
}


Arg ifarg() : {
Arg result = new Arg();
Expression node1 = null;
}
{
	node1=expr()
	{
		result.setExpression(node1);
		return result;
	}
	| "@" node1=expratom()
	{
	    result.setExpression(new IndirectExpression(node1));
		return result;
	}
}

JobCommand jobcommand() : {
PostCondition node1 = null;
ArgList node2 = null;
}
{
	<JOB> ( node1=postcond() )? " " node2=jobarglist()
	{
		JobCommand node = new JobCommand(node1);
		node.setArgList(node2);
		return node;
	}
}

ArgList jobarglist() : {
ArgList result = new ArgList();
Arg node1 = null;
Arg node2 = null;
}
{
	node1=jobarg() {result.add(node1);} ( "," node2=jobarg() {result.add(node2);} )*
	{
		return result;
	}
}

Arg jobarg() : {
Arg result = new JobArg();
Expression node1 = null;
ArgList node2 = null;
JobParam node3 = null;
}
{
	"@" node1=expratom()
	{
	   result.setExpression(new IndirectExpression(node1));
	   return result;
	}
    | node1=entryref() ( ":" node3=jobparams() )?
    {
        ((JobArg)result).setJobParams(node3);
        result.setExpression(node1);
        return result;
    }
	| node1=labelref() node2=actuallist() ( ":" node3=jobparams() )?
    {
        ((JobArg)result).setJobParams(node3);
        ((LabelRef)node1).setArgList(node2);
        result.setExpression(node1);
        return result;
    }
}

Expression labelref() : {
LabelRef result = new LabelRef();
Token n1 = null;
Token n2 = null;
Expression node1 = null;
}
{
	n1=<NAME> (( "^" ( "|" node1=environment() "|" )? ) | " ") n2=<NAME>
	{
	   if (n1 != null) {
	       result.setName(n1.toString());
	   }
       if (n2 != null) {
           result.setRoutine(n2.toString());
       }
       result.setEnvironment(node1);
	   return result;
	}
	| "^" ( "|" node1=environment() "|" )?  n2=<NAME>
    {
       if (n2 != null) {
           result.setRoutine(n2.toString());
       }
       result.setEnvironment(node1);
       return result;
    }
}

Expression environment() : {
Expression result = null;
}
{
	result=expr()
	{
	   return result;
	}
}

ArgList actuallist() : {
ArgList result = new ArgList();
Arg node1 = null;
Arg node2 = null;
}
{
	"(" ( node1=actualorexpr() {result.add(node1);} ( "," node2=actualorexpr() {result.add(node2);} )* )? ")"
	{
	   return result;
	}
}

Arg actualorexpr() : {
Arg result = new Arg();
Expression node2 = null;
Expression node1 = null;
Token n1 = null;
}
{
    "." ( n1=<NAME> | "@" node1=expratom() )
    {
        node2 = new ActualNameExpression();
        if (n1 != null) {
            ((ActualNameExpression)node2).setName(n1.toString());
        }
        else if (node1 != null) {
            ((ActualNameExpression)node2).setIndirectExpression(new IndirectExpression(node1));
        }
        result.setExpression(node2);
        return result; 
    }
    | node2=expr()
    {
        result.setExpression(node2);
        return result;
    }
}

JobParam jobparams() : {
JobParam result = new JobParam();
Expression node1 = null;
Expression node2 = null;
ArgList arglist = null;
}
{
    arglist=processparams() ( " " node2=expr() )?
	{
	    result.setProcessParams(arglist);
	    result.setTimeout(node2);
	    return result;
	}
    // spec is ambiguous around expr() whether it is a process param or a timeout
    // so we're going to shoe-horn it into being a timeout
	| node1=expr() ( " " node2=expr() )?
	{
	   if (node2 != null) {
           result.setTimeout(node2);
           arglist = new ArgList();
           result.setProcessParams(arglist);
           arglist.add(new Arg(node1));
	   }
	   else {
	       result.setTimeout(node1);
	   }
	   return result;
	}
}

ArgList processparams() : {
ArgList result = new ArgList();
Expression node1 = null;
Expression node2 = null;
}
{
    "(" node1=expr() {result.add(new Arg(node1));} ( ":" node2=expr() {result.add(new Arg(node2));} )* ")"
    {
        return result;
    }
}

KillCommand killcommand() : {
PostCondition node1 = null;
ArgList node2 = null;
}
{
	LOOKAHEAD( 3 )
	<KILL> ( node1=postcond() )? " " node2=killarglist() 
	{
		KillCommand node = new KillCommand(node1);
		node.setArgList(node2);
		return node;
	}
	| <KILL> ( node1=postcond() )? (" ")*
	{
		return new KillCommand(node1);
	}
}

ArgList killarglist() : {
ArgList result = new ArgList();
Arg node1 = null;
Arg node2 = null;
}
{
	node1=killarg() {result.add(node1);} ( "," node2=killarg() {result.add(node2);} )*
	{
		return result;
	}
}

Arg killarg() : {
Arg result = new Arg();
Expression node1 = null;
ArgList node3 = null;
}
{
	 "@" node1=expratom()
	{
		result.setExpression(new IndirectExpression(node1));
		return result;
	}
	| node3=lnamelist()
	{
	    result = new ExclusiveArg();
	    result.setExpression(node3);
	    return result;
	}
	| node1=glvn()
	{
		result.setExpression(node1);
		return result;
	}
}

ArgList lnamelist() : {
ArgList result = new ArgList();
Arg node1 = null;
Arg node2 = null;
}
{
	"(" ( node1=lname() {result.add(node1);} ( "," node2=lname() {result.add(node1);} )* )? ")"
	{
		return result;
	}
}

Arg lname() : {
Arg result = new Arg();
Expression node1 = null;
Token n1;
}
{
	"@" node1=expratom() 
	{
	    result.setExpression(new IndirectExpression(node1));
		return result;
	}
	| n1=<NAME>
	{
	    result.setExpression(new LocalVariableExpression(n1.toString(), null));
	    return result;
	}
}

LockCommand lockcommand() : {
PostCondition node1 = null;
ArgList node2 = null;
}
{
	<LOCK> ( node1=postcond() )? ( " " ( node2=lockargparens() )? )?
	{
		LockCommand node = new LockCommand(node1);
		node.setArgList(node2);
		return node;
	}
}

ArgList lockargparens() : {
ArgList result = null;
}
{
    "(" ( result=lockarglist() )? ")"
    {
        if (result == null) {
            result = new ArgList();
        }
        
        return result;
    }
    |
    result=lockarglist()
    {
        return result;
    }
}

ArgList lockarglist() : {
ArgList result = new ArgList();
}
{
	lockarg() {result.add(new Arg());} ( "," lockarg() {result.add(new Arg());} )*
	{
		return result;
	}
	// TODO - the grammar is ambiguous here. there is also the possibility of a @expratom interpreted as a lock arg list
	// but that is ambiguous with a @expratom interpreted as a nref.
	|  "@" expratom()
	{
	   result.setLiveArg("expratom");  // TODO - get the correct value here.
	   return result;
	}
}

void lockarg() : {
Token n1;
Expression node2 = null;
}
{
	( n1="+" | n1="-" )? ( ( "(" nreflist() ")" ) | nref() ) ( " " node2=expr() )?
}

void nreflist() : {}
{
	nref() ( "," nref() )*
}

void nref() : {
	Token n1;
	Token n2;
}
{
	( "^" )? ( "|" n1=<NAME> "|" )? n2=<NAME> ( "(" exprlist() ")" )?
// | "@" expratom()  // suppressed for now because its ambiguous
}

MergeCommand mergecommand() : {
PostCondition node1 = null;
ArgList node2 = null;
}
{
	<MERGE> ( node1=postcond() )? " " node2=mergearglist()
	{
// TODO: implement
		MergeCommand node = new MergeCommand(node1);
		node.setArgList(node2);
		return node;
	}
}

ArgList mergearglist() : {
ArgList result = new ArgList();
}
{
	mergearg() {result.add(new Arg());} ( "," mergearg() {result.add(new Arg());} )*
	{
		return result;
	}
}

void mergearg() : {}
{
	"@" expratom()
	| glvn() "=" glvn() 
}

NewCommand newcommand() : {
PostCondition node1 = null;
ArgList node2 = null;
}
{
	<NEW> ( node1=postcond() )? ( (" " node2=newarglist()) | ( " " )? )
	{
// TODO: implement
		NewCommand node = new NewCommand(node1);
		node.setArgList(node2);
		return node;
	}
}

ArgList newarglist() : {
ArgList result = new ArgList();
}
{
	newarg() {result.add(new Arg());} ( "," newarg() {result.add(new Arg());} )*
	{
		return result;
	}
}

void newarg() : {}
{
	"@" expratom()
	| lnamelist() 
	| lname()
	// TODO: newsvn
}

OpenCommand opencommand() : {
PostCondition node1 = null;
ArgList node2 = null;
}
{
	<OPEN> ( node1=postcond() )? " " node2=openarglist()
	{
// TODO: implement
		OpenCommand node = new OpenCommand(node1);
		node.setArgList(node2);
		return node;
	}
}

ArgList openarglist() : {
ArgList result = new ArgList();
}
{
	openarg() {result.add(new Arg());} ( "," openarg() {result.add(new Arg());} )*
	{
		return result;
	}
}
	
void openarg() : {}
{
	"@" expratom()
	| expr() ( ":" openparameters() )?
}
	
void openparameters() : {}
{
    // TODO - the grammar is ambiguous around deviceparams() = expr() and expr()
	deviceparams() ( expr() ( ":" expr() )? )?
	| ( deviceparams() )? "::" mnemonicspec()
	| expr() ( ":" mnemonicspec() )?
}

void mnemonicspec() : {}
{
	"(" mnemonicspace() ( "," mnemonicspace() )* ")"
	| mnemonicspace()
}

void mnemonicspace() : {}
{
	expr()
}

QuitCommand quitcommand() : {
PostCondition node1 = null;
Expression node2 = null;
}
{
	<QUIT> ( node1=postcond() )? (" ")* ( node2=expr() )?
	{
// TODO: implement
		QuitCommand node = new QuitCommand(node1);
		node.setReturnExpression(node2);
		return node;
	}
}

ReadCommand readcommand() : {
PostCondition node1 = null;
ArgList node2 = null;
}
{
	<READ> ( node1=postcond() )? " " node2=readarglist()
	{
// TODO: implement
		ReadCommand node = new ReadCommand(node1);
		node.setArgList(node2);
		return node;
	}
}

ArgList readarglist() : {
ArgList result = new ArgList();
}
{
	readarg() {result.add(new Arg());} ( "," readarg() {result.add(new Arg());} )*
	{
		return result;
	}
}

void readarg() : {}
{
	"@" expratom()
	| "*" glvn() ( " " expr() )?
	| glvn() ( "#" expr() )? ( " " expr() )?
	| ( format() )+
	| <STRLIT>
}

void format() : {}  // TODO
{
	"!"
	| "#"
	| "?"
}

SetCommand setcommand() : {
	PostCondition node1 = null;
	ArgList node2 = null;
}
{
	<SET> ( node1=postcond() )? " " node2=setlist()
	{
		SetCommand node = new SetCommand(node1);
		node.setArgList(node2);
		return node;
	}
}

ArgList setlist() : {
ArgList result = new ArgList();
Arg node1 = null;
Arg node2 = null;
}
{
	node1=setatom() {result.add(node1);} ( "," node2=setatom() {result.add(node2);} )*
	{ 
	   return result; 
	}
}

Arg setatom() : {
Arg result = new Arg();
Expression node1 = null;
}
{
    "@" node1=expratom()
    {
        result.setExpression(new IndirectExpression(node1));
        return result;
    }
	| setdestination() "=" expr()
	{
	   return result;
	}
}

void setdestination() : {}
{
	"(" setleftlist() ")"
	| setleft()
}

void setleftlist() : {}
{
	setleft() ( "," setleft() )*
}

void setleft() : {
Expression node1 = null;
}
{
	leftrestricted()
	| leftexpr()
	| glvn()
	
}

void leftrestricted() : {}
{
	( <V_DEVICE> | <F_DATA> )  // TODO - need to throw an exception on "$DATA" which does not match
	| <V_KEY>
	| <V_X>
	| <V_Y>
}

void leftexpr() : {}
{
	setev()
	| setextract()
	| setpiece()
}

void setev() : {}
{
	<V_ECODE>
	| <V_ETRAP>
}

void setextract() : {}
{
	<F_EXTRACT> "(" glvn() "," expr() ( "," expr() )? ")"
}

void setpiece() : {}
{
	<F_PIECE> "(" glvn() "," expr() ( "," expr() )? ( "," expr() )? ")"
}

UseCommand usecommand() : {
PostCondition node1 = null;
ArgList node2 = null;
}
{
	<USE> ( node1=postcond() )? " " node2=usearglist()
	{
// TODO: implement
		UseCommand node = new UseCommand(node1);
		node.setArgList(node2);
		return node;
	}
}

ArgList usearglist() : {
ArgList result = new ArgList();
Arg node1 = null;
Arg node2 = null;
}
{
	node1=usearg() {result.add(node1);} ( "," node2=usearg() {result.add(node2);} )*
	{
		return result;
	}
}

Arg usearg() : {
Arg result = new Arg();
}
{
	"@" expratom()
	{
	   return result;
	}
	| expr() ( ":" deviceparams() )? ( ":" mnemonicspace() )?
	{
	   return result;
	}
}

ViewCommand viewcommand() : {
PostCondition node1 = null;
}
{
	<VIEW> ( node1=postcond() )? 
	{
// TODO: implement
		ViewCommand node = new ViewCommand(node1);
		return node;
	}
}

WriteCommand writecommand() : {
PostCondition node1 = null;
ArgList node2 = null;
}
{
	<WRITE> ( node1=postcond() )? " " node2=writearglist()
	{
// TODO: implement
		WriteCommand node = new WriteCommand(node1);
		node.setArgList(node2);
		return node;
	}
}

ArgList writearglist() : {
ArgList result = new ArgList();
Arg node1 = null;
Arg node2 = null;
}
{
	node1=writearg() {result.add(node1);} ( "," node2=writearg() {result.add(node2);} )*
	{
		return result;
	}
}

Arg writearg() : {
Arg result = new Arg();
}
{
	"@" expratom()
	{
	   return result;
	}
	| "*" expr()
	{
	   return result;
	}
	| ( format() )+
	{
	   return result;
	}
	| expr()
	{
	   return result;
	}
}

XecuteCommand xecutecommand() : {
PostCondition node1 = null;
ArgList node2 = null;
}
{
	<XECUTE> ( node1=postcond() )? " " node2=xarglist()
	{
// TODO: implement
		XecuteCommand node = new XecuteCommand(node1);
		node.setArgList(node2);
		return node;
	}
}

ArgList xarglist() : {
ArgList result = new ArgList();
}
{
	xarg() {result.add(new Arg());} ( "," xarg() {result.add(new Arg());} )*
	{
		return result;
	}
}

void xarg() : {
PostCondition node1 = null;
}
{
	"@" expratom()
	| expr() ( node1=postcond() )?
}

PostCondition postcond() : {
SimpleNode node1 = null;
Expression node2 = null;
}
{
	":" node2=tvexpr()
	{ 
	   return new PostCondition(node2); 
	}
}

Expression tvexpr() : {
Expression node1 = null;
}
{
	 node1=expr()
	{
	   return node1; 
	}
}

Expression expr() : {
Expression node1 = null;
Expression node2 = null;
}
{
	 node1=expratom() ( node2=exprtail() {node1 = leftRightBind(node1, node2);} )*
	{
	    return node1;
	}
}

Expression expratom() : {
Expression result = null;
}
{
    "@" result=expratom()
    {
       return new IndirectExpression(result);
    }
	| result=glvn()
	{
	   return result;
	} 
	| result=expritem() 
	{
	   return result;
	}
}

Expression exprtail() : {
Expression result = null;
Expression node2 = null;
Token n1 = null;
Token n2 = null;
}
{
	 ( n2="\'" )? n1=relation() node2=expratom()
     {
         String op = n2 == null ? n1.toString() : (n2.toString() + n1.toString());
         return new RelationExpression(op, null, node2);
     }
	 | ( n2="\'" )? n1=logicalop() node2=expratom()
     {
         String op = n2 == null ? n1.toString() : (n2.toString() + n1.toString());
         return new LogicalExpression(op, null, node2);
     }
	 | ( n2="\'" )? n1="?" "."  // TODO- this is for  "'?pattern" 
     {
         String op = n2 == null ? n1.toString() : (n2.toString() + n1.toString());
         return new MatchExpression(op, null, new StringConstant("pattern"));  // TODO - fix this pattern arg.
     }
	 | ( n2="\'" )? n1="?" "@" node2=expratom()    
	 {
         String op = n2 == null ? n1.toString() : (n2.toString() + n1.toString());
         return new MatchExpression(op, null, new IndirectExpression(node2)); 
     }
     | n1=binaryop() node2=expratom()
     {
         return new BinaryExpression(n1.toString(), null, node2);
     }
}

Expression glvn() : {
Expression result = null;
} 
{
	LOOKAHEAD( 3 )
	result=lvn() 
    {
        return result;
    }
	| result=gvn () 
    {
        return result;
    }
	| result=ssvn() 
    {
        return result;
    }
}

Expression lvn() : {
Token n1;
Token n2 = null;
ArgList node1 = null;
} 
{
    // TODO - the grammar is ambiguous around "@foo" interpreted as a lvn
    // and it's worse around "@label@(expressions)"
  	n1=<NAME> ( n2="(" ( node1=exprlist() )? ")" )?
	{
	   LocalVariableExpression result = new LocalVariableExpression(n1.toString(), null);
	   result.setArgList(node1);
	   
	   if (n2 != null && node1 == null) {
	       result.setArgList(new ArgList());
	   }
	   return result;
	}
}

ArgList exprlist() : {
ArgList result = new ArgList();
Expression node1 = null;
Expression node2 = null;
}  
{
	node1=expr() ("," node2=expr() {Arg arg2=new Arg();arg2.setExpression(node2);result.add(arg2);} )*
	{
	   Arg arg = new Arg();
	   arg.setExpression(node1);
	   result.add(arg);  // TODO- might be adding in the wrong order (with node1 last instead of first)
	   return result;
	} 
}

Expression gvn() : {
GlobalVariableExpression result = null;
Expression node1 = null;
ArgList node2 = null;
Token n1 = null;
Token n2 = null;
}
{
	"^" ( "|" n2=<NAME> "|" )?  node1=lvn()
	{
	   result = new GlobalVariableExpression((LocalVariableExpression)node1);
	   if (n2 != null) {
	       result.setEnvironmentName(n2.toString());
	   }
	   return result;
	}
	| "^" n1="(" ( node2=exprlist() )? ")"
	{
	   result = new GlobalVariableExpression();
	   result.setArgList(node2);
	   if (n1 != null && node2 == null) {
	       result.setArgList(new ArgList());
	   }
	   return result;
	}
}

Expression ssvn() : {
StructuredSystemVariableExpression result = new StructuredSystemVariableExpression();
Token n1;
Token n2 = null;
ArgList node2 = null;
}
{  // TODO - instead of parsing all of these var name tokens individually, you could parse them into a single name and post-process the AST.
// and that will also help deal with $Zwhatever() variable names

    "^" n1=<SV_CHARACTER> n2="(" ( node2=exprlist() )? ")"
	{
        result.setName("$CHARACTER");
        result.setArgList(node2);
		return result;
	}
    | "^" n1=<F_CHAR> n2="(" ( node2=exprlist() )? ")"  // silly alias for "$C"
	{
	   if (!"$C".equals(n1.toString())) {
	       throw new RuntimeException("Error parsing stuff");
	   }
        result.setName("$CHARACTER");
        result.setArgList(node2);
        return result;
	}
    | "^" n1=<V_DEVICE> n2="(" ( node2=exprlist() )? ")"
    {
        result.setName("$DEVICE");
        result.setArgList(node2);
        return result;
    }
    | "^" n1=<F_DATA> n2="(" ( node2=exprlist() )? ")"  // silly alias for "$D"
    {
       if (!"$D".equals(n1.toString())) {
           throw new RuntimeException("Error parsing stuff");
       }
        result.setName("$DEVICE");
        result.setArgList(node2);
        return result;
    }
    | "^" n1=<SV_GLOBAL> n2="(" ( node2=exprlist() )? ")"
    {
        result.setName("$GLOBAL");
        result.setArgList(node2);
        return result;
    }
    | "^" n1=<F_GET> n2="(" ( node2=exprlist() )? ")"  // silly alias for "$G"
    {
       if (!"$G".equals(n1.toString())) {
           throw new RuntimeException("Error parsing stuff");
       }
        result.setName("$GLOBAL");
        result.setArgList(node2);
        return result;
    }
    | "^" n1=<V_JOB> n2="(" ( node2=exprlist() )? ")"
    { 
        result.setName("$JOB");
        result.setArgList(node2);
        return result;
    }
    | "^" n1=<F_JUSTIFY> n2="(" ( node2=exprlist() )? ")"  // silly alias for "$J"
    {
       if (!"$J".equals(n1.toString())) {
           throw new RuntimeException("Error parsing stuff");
       }
        result.setName("$JOB");
        result.setArgList(node2);
        return result;
    }
    | "^" n1=<SV_LOCK> n2="(" ( node2=exprlist() )? ")"
    {
        result.setName("$LOCK");
        result.setArgList(node2);
        return result;
    }
    | "^" n1=<F_LENGTH> n2="(" ( node2=exprlist() )? ")"  // silly alias for "$L"
    {
       if (!"$L".equals(n1.toString())) {
           throw new RuntimeException("Error parsing stuff");
       }
        result.setName("$LOCK");
        result.setArgList(node2);
        return result;
    }
    | "^" n1=<SV_ROUTINE> n2="(" ( node2=exprlist() )? ")"
    {
        result.setName("$ROUTINE");
        result.setArgList(node2);
        return result;
    }
    | "^" n1=<F_RANDOM> n2="(" ( node2=exprlist() )? ")"  // silly alias for "$R"
    {
       if (!"$R".equals(n1.toString())) {
           throw new RuntimeException("Error parsing stuff");
       }
        result.setName("$ROUTINE");
        result.setArgList(node2);
        return result;
    }
    | "^" n1=<V_SYSTEM> n2="(" ( node2=exprlist() )? ")"
	{
        result.setName("$SYSTEM");
        result.setArgList(node2);
        return result;
	}
    | "^" n1=<F_SELECT> n2="(" ( node2=exprlist() )? ")"  // silly alias for "$S"
    {
       if (!"$S".equals(n1.toString())) {
           throw new RuntimeException("Error parsing stuff");
       }
        result.setName("$SYSTEM");
        result.setArgList(node2);
        return result;
    }
}

Expression function() : {
FunctionExpression result = new FunctionExpression();
Token n1;
Token n2 = null;
ArgList node2 = null;
}
{  // TODO - instead of parsing all of these var name tokens individually, you could parse them into a single name and post-process the AST.
// and that will also help deal with $Zwhatever() variable names

    n1=<F_ASCII> n2="(" ( node2=exprlist() )? ")"
    {
        result.setName("$ASCII");
        result.setArgList(node2);
        return result;
    }
    | n1=<F_CHAR> n2="(" ( node2=exprlist() )? ")"
    {
        result.setName("$CHAR");
        result.setArgList(node2);
        return result;
    }
    | n1=<F_DATA> n2="(" ( node2=exprlist() )? ")"
    {
        result.setName("$DATA");
        result.setArgList(node2);
        return result;
    }
    | n1=<F_EXTRACT> n2="(" ( node2=exprlist() )? ")"
    {
        result.setName("$EXTRACT");
        result.setArgList(node2);
        return result;
    }
    | n1=<F_FIND> n2="(" ( node2=exprlist() )? ")"
    {
        result.setName("$FIND");
        result.setArgList(node2);
        return result;
    }
    | n1=<F_FNUMBER> n2="(" ( node2=exprlist() )? ")"
    {
        result.setName("$FNUMBER");
        result.setArgList(node2);
        return result;
    }
    | n1=<F_GET> n2="(" ( node2=exprlist() )? ")"
    {
        result.setName("$GET");
        result.setArgList(node2);
        return result;
    }
    | n1=<F_JUSTIFY> n2="(" ( node2=exprlist() )? ")"
    {
        result.setName("$JUSTIFY");
        result.setArgList(node2);
        return result;
    }
    | n1=<F_LENGTH> n2="(" ( node2=exprlist() )? ")"
    {
        result.setName("$LENGTH");
        result.setArgList(node2);
        return result;
    }
    | n1=<F_NAME> n2="(" ( node2=exprlist() )? ")"
    {
        result.setName("$NAME");
        result.setArgList(node2);
        return result;
    }
    | n1=<F_ORDER> n2="(" ( node2=exprlist() )? ")"
    {
        result.setName("$ORDER");
        result.setArgList(node2);
        return result;
    }
    | n1=<F_PIECE> n2="(" ( node2=exprlist() )? ")"
    {
        result.setName("$PIECE");
        result.setArgList(node2);
        return result;
    }
    | n1=<F_QLENGTH> n2="(" ( node2=exprlist() )? ")"
    {
        result.setName("$QLENGTH");
        result.setArgList(node2);
        return result;
    }
    | n1=<F_QSUBSCRIPT> n2="(" ( node2=exprlist() )? ")"
    {
        result.setName("$QSUBSCRIPT");
        result.setArgList(node2);
        return result;
    }
    | n1=<F_QUERY> n2="(" ( node2=exprlist() )? ")"
    {
        result.setName("$QUERY");
        result.setArgList(node2);
        return result;
    }
    | n1=<F_RANDOM> n2="(" ( node2=exprlist() )? ")"
    {
        result.setName("$RANDOM");
        result.setArgList(node2);
        return result;
    }
    | n1=<F_REVERSE> n2="(" ( node2=exprlist() )? ")"
    {
        result.setName("$REVERSE");
        result.setArgList(node2);
        return result;
    }
    | n1=<F_SELECT> n2="(" ( node2=exprlist() )? ")"
    {
        result.setName("$SELECT");
        result.setArgList(node2);
        return result;
    }
    | n1=<F_STACK> n2="(" ( node2=exprlist() )? ")"
    {
        result.setName("$STACK");
        result.setArgList(node2);
        return result;
    }
    | n1=<F_TEXT> n2="(" ( node2=exprlist() )? ")"
    {
        result.setName("$TEXT");
        result.setArgList(node2);
        return result;
    }
    | n1=<F_TRANSLATE> n2="(" ( node2=exprlist() )? ")"
    {
        result.setName("$TRANSLATE");
        result.setArgList(node2);
        return result;
    }
    | n1=<F_VIEW> n2="(" ( node2=exprlist() )? ")"
    {
        result.setName("$VIEW");
        result.setArgList(node2);
        return result;
    }
}
    
    
Expression expritem() : {
Expression result = null;
Expression node1 = null;
Token n1 = null;
}  // TODO
{
// strlit
// numlit
// exfunc
// exvar   $externref or $$labelref
// svn   $X, $DEVICE, and so on...
// function
// unaryop expratom
// ( expr )

	n1=<NUMBER> 
    {
        return new NumericConstant(n1.toString());
    }
    | n1=<STRLIT>
    {
        return new StringConstant(n1.toString());
    }
    | n1=unaryop() node1=expratom()
    {
        return new UnaryExpression(n1.toString(), node1);
    }
    | "(" node1=expr() ")"
    {
        return node1;   
    }
    | node1=function()
    {
        return node1;
    }
}

Token unaryop() : {
Token n1 = null;
}
{
	n1="\'" 
    {
    return n1;
    }
	| n1="+" 
    {
    return n1;
    }
	| n1="-"
	{
	return n1;
	}
}

Token binaryop() : {
Token n1 = null;
}
{
	n1="_" 
    {
       return n1;
    }
	| n1="+" 
    {
       return n1;
    }
	| n1="-" 
    {
       return n1;
    }
	| n1="*" 
    {
       return n1;
    }
	| n1="/" 
    {
       return n1;
    }
	| n1="#" 
    {
       return n1;
    }
	| n1="\\" 
    {
       return n1;
    }
	| n1="**"
	{
	   return n1;
	}
}

Token relation() : {
Token n1 = null;
}
{
	n1="=" 
    {
       return n1;
    }
	| n1="<" 
    {
       return n1;
    }
	| n1=">" 
    {
       return n1;
    }
	| n1="]" 
    {
       return n1;
    }
	| n1="[" 
    {
       return n1;
    }
	| n1="]]"
	{
	   return n1;
	}
}

Token logicalop() : {
Token n1 = null;
}
{
	n1="&" 
	{
    return n1;
    }
	| n1="!" 
    {
    return n1;
    }
}
