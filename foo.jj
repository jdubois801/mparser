
options {
	LOOKAHEAD = 2;
	STATIC = false;
}

PARSER_BEGIN(FooParser)
package com;
import java.io.StringBufferInputStream;
import com.ast.*;

public class FooParser {
	public static final String TEST_DATA = 
	"XXROUTINE ;c\r\n"+
	" ;comment\r\n"+
	" B \r\n"+
	" C \r\n"+
	" Q:'1 \r\n"
	;

	public static void main(String[] args) {
		FooParser fp = new FooParser(new StringBufferInputStream(TEST_DATA));
		
		try {
			fp.routine();
		} catch (ParseException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		System.out.println("accept");
	}
}

PARSER_END(FooParser)

// lexical tokens
TOKEN : {
   < EOL : "\r\n" >
 | < EOR : "\r\f" >
 | < COMMENT : ";" (~["\r"])* >
 | < #LETTER : ["a"-"z","A"-"Z"] >
 | <NUMBER : (<DIGIT>)+ > 
 | < DIGIT : ["0"-"9"] >
}

// basic commands
TOKEN : {
   < BREAK : "B"("REAK")? >
 | < CLOSE : "C"("LOSE")? >
 | < DO : "D"("O")? >
 | < ELSE : "E"("LSE")? >
 | < FOR : "F"("OR")? >
 | < GOTO : "G"("OTO")? >
 | < HALT: "H"("ALT"|"ANG")?>
 | < IF : "I"("F")? >
 | < JOB : "J"("OB")? >
 | < KILL : "K"("ILL")? >
 | < LOCK : "L"("OCK")? >
 | < MERGE : "M"("ERGE")? >
 | < NEW : "N"("EW")? >
 | < OPEN : "O"("PEN")? >
 | < QUIT : "Q"("UIT")? >
 | < READ : "R"("EAD")? >
 | < SET : "S"("ET")? >
 | < USE : "U"("SE")? >
 | < VIEW : "V"("IEW")? >
 | < WRITE : "W"("RITE")? >
 | < XECUTE : "X"("ECUTE")? >
}

// built-in functions
TOKEN : {
   < F_ASCII : "$A"("SCII")? >
 | < F_CHAR : "$C"("HAR")? >
 | < F_DATA : "$D"("ATA")? >
 | < F_EXTRACT : "$E"("XTRACT")? >
 | < F_FIND : "$F"("IND")? >
 | < F_FNUMBER : "$FN"("UMBER")? >
 | < F_GET : "$G"("ET")? >
 | < F_JUSTIFY : "$J"("USTIFY")? >
 | < F_LENGTH : "$L"("ENGTH")? >
 | < F_NAME : "$NA"("ME")? >
 | < F_ORDER : "$O"("RDER")? >
 | < F_PIECE : "$P"("IECE")? >
 | < F_QLENGTH : "$QL"("ENGTH")? >
 | < F_QSUBSCRIPT : "$QS"("UBSCRIPT")? >
 | < F_QUERY : "$Q"("UERY")? >
 | < F_RANDOM : "$R"("ANDOM")? >
 | < F_REVERSE : "$RE"("VERSE")? >
 | < F_SELECT : "$S"("ELECT")? >
 | < F_STACK : "$ST"("ACK")? >
 | < F_TEXT : "$T"("EXT")? >
 | < F_TRANSLATE : "$TR"("ANSLATE")? >
 | < F_VIEW : "$V"("IEW")? >
}

// built-in variables
TOKEN : {
    <V_DEVICE : "$D"("EVICE")? >
  | <V_ECODE : "$EC"("ODE")? >
  | <V_ESTACK : "$ES"("TACK")? >
  | <V_HORLOG : "$H"("ORLOG")? >
  | <V_IO : "$I"("O")? >
  | <V_JOB : "$J"("OB")? >
  | <V_KEY : "$K"("EY")? >
  | <V_PRINCIPAL : "$P"("RINCIPAL")? >
  | <V_QUIT : "$Q"("UIT")? >
  | <V_REFERENCE : "$R"("EFERENCE")? >
  | <V_STORAGE : "$S"("TORAGE")? >
  | <V_SYSTEM : "$SY"("STEM")? >
  | <V_TEST : "$T"("EST")? >
  | <V_X : "$X" >
  | <V_Y : "$Y" >
}

// structured system variables
TOKEN : {
    <SV_GLOBAL : "^$G"("LOBAL")? >
  | <SV_JOB : "^$J"("OB")? >
  | <SV_LOCK : "^$L"("OCK")? >
  | <SV_ROUTINE : "^$R"("OUTINE")? >
  | <SV_SYSTEM : "^$S"("YSTEM")? >
}

// identifiers
TOKEN : {
   < NAME : ("%"|<LETTER>)(<LETTER>|<DIGIT>)* >  // not strictly correct since "%" isn't a valid name
  | <STRLIT : "\"" (["a"-"z"])* "\"" > 
}


void routine() : {}
{
	routinehead()
	routinebody()
}

void routinehead() : {}
{
	<NAME> ( (" ")* <COMMENT>)? <EOL>
	{
		System.out.println("routinehead()");
	}
}

void routinebody() : {}
{
	( line() )* ( <EOR> | <EOF> )
	{
		System.out.println("routinebody()");
	}
}

void line() : {}
{
	levelline() | formalline() 
}

void levelline() : {}
{
	( label() )? " " ( li() " " )* linebody()
	{
		System.out.println("levelline()");
	}
}

void label() : {}
{
	 <NAME> | <NUMBER>
	{
		System.out.println("label()");
	}
}

void li() : {}
{
	"."
	{
		System.out.println("li()");
	}
}

void formalline() : {}
{
	label() formallist() (" ")+ linebody()
	{
		System.out.println("formalline()");
	}
}

void linebody() : {}
{
	commandscomment() 
	| commandsextsyntax()
	| ( <COMMENT> <EOL> )
}

void formallist() : {}
{
	"(" (<NAME> ( formallistitem() )* )? ")"
	{
		System.out.println("formallist()");
	}
}

void formallistitem() : {}
{
	"," <NAME>
	{
		System.out.println("formallistitem()");
	}
}

void commandscomment() : {}
{
	commands() (" ")* (<COMMENT> | extsyntax())? <EOL>
	{
		System.out.println("commandscomment()");
	}
}

void commandsextsyntax() : {}
{
	extsyntax() <EOL>
	{
		System.out.println("commandsextsyntax()");
	}
}

void commands() : {}
{
	command() ( (" ")* command() )*
	{
		System.out.println("commands()");
	}
}

void command() : { System.err.println("command()");
}
{
	breakcommand()
	| closecommand()
	| docommand()
	| elsecommand()
	| forcommand()
	| gotocommand()
	| haltcommand()
	| ifcommand()
	| jobcommand()
	| killcommand()
	| lockcommand()
	| mergecommand()
	| newcommand()
	| opencommand()
	| quitcommand()
	| readcommand()
	| setcommand()
	| usecommand()
	| viewcommand()
	| writecommand()
	| xecutecommand()
}

void extsyntax() : {}  // TODO
{
	"&SQL" "(" (".")* ")" 
	{
		System.out.println("extsyntax()");
	}
}

void breakcommand() : {}
{
	<BREAK> ( postcond() )? 
	{
// TODO: implement
		AstNode node = new BreakCommand();
		System.out.println("breakcommand()");
	}
}

void closecommand() : {}
{
	<CLOSE> ( postcond() )? 
	{
// TODO: implement
		AstNode node = new CloseCommand();
		System.out.println("closecommand()");
	}
}

void docommand() : {}
{
	<DO> ( postcond() )? 
	{
// TODO: implement
		AstNode node = new DoCommand();
		System.out.println("docommand()");
	}
}

void elsecommand() : {}
{
	<ELSE>
	{
// TODO: implement
		AstNode node = new ElseCommand();
		System.out.println("elsecommand()");
	}
}

void forcommand() : {}
{
	<FOR>
	{
// TODO: implement
		AstNode node = new ForCommand();
		System.out.println("forcommand()");
	}
}

void gotocommand() : {}
{
	<GOTO> ( postcond() )? 
	{
// TODO: implement
		AstNode node = new GotoCommand();
		System.out.println("gotocommand()");
	}
}

void haltcommand() : {}
{
	// deal with <HANG> also
	<HALT> ( postcond() )? 
	{
// TODO: implement
		AstNode node = new HaltCommand();
		System.out.println("haltcommand()");
	}
}

void ifcommand() : {}
{
	<IF>
	{
// TODO: implement
		AstNode node = new IfCommand();
		System.out.println("ifcommand()");
	}
}

void jobcommand() : {}
{
	<JOB> ( postcond() )? 
	{
// TODO: implement
		AstNode node = new JobCommand();
		System.out.println("jobcommand()");
	}
}

void killcommand() : {}
{
	<KILL> ( postcond() )? 
	{
// TODO: implement
		AstNode node = new KillCommand();
		System.out.println("killcommand()");
	}
}

void lockcommand() : {}
{
	<LOCK> ( postcond() )? 
	{
// TODO: implement
		AstNode node = new LockCommand();
		System.out.println("lockcommand()");
	}
}

void mergecommand() : {}
{
	<MERGE> ( postcond() )? 
	{
// TODO: implement
		AstNode node = new MergeCommand();
		System.out.println("mergecommand()");
	}
}

void newcommand() : {}
{
	<NEW> ( postcond() )? 
	{
// TODO: implement
		AstNode node = new NewCommand();
		System.out.println("newcommand()");
	}
}

void opencommand() : {}
{
	<OPEN> ( postcond() )? 
	{
// TODO: implement
		AstNode node = new OpenCommand();
		System.out.println("opencommand()");
	}
}

void quitcommand() : {System.err.println("quitcommand(1)");}
{
	<QUIT> ( postcond() )? 
	{
// TODO: implement
		AstNode node = new QuitCommand();
		System.out.println("quitcommand(2)");
	}
}

void readcommand() : {}
{
	<READ> ( postcond() )? 
	{
// TODO: implement
		AstNode node = new ReadCommand();
		System.out.println("readcommand()");
	}
}

void setcommand() : {}
{
	<SET> ( postcond() )? 
	{
// TODO: implement
		AstNode node = new SetCommand();
		System.out.println("setcommand()");
	}
}

void usecommand() : {}
{
	<USE> ( postcond() )? 
	{
// TODO: implement
		AstNode node = new UseCommand();
		System.out.println("usecommand()");
	}
}

void viewcommand() : {}
{
	<VIEW> ( postcond() )? 
	{
// TODO: implement
		AstNode node = new ViewCommand();
		System.out.println("viewcommand()");
	}
}

void writecommand() : {}
{
	<WRITE> ( postcond() )? 
	{
// TODO: implement
		AstNode node = new WriteCommand();
		System.out.println("writecommand()");
	}
}

void xecutecommand() : {}
{
	<XECUTE> ( postcond() )? 
	{
// TODO: implement
		AstNode node = new XecuteCommand();
		System.out.println("xecutecommand()");
	}
}

void postcond() : {System.err.println("postcond");}
{
	":" tvexpr()
}

void tvexpr() : {}
{
	 expr()
}

void expr() : {System.err.println("expr");}
{
	 expratom() (exprtail())*
}

void expratom() : {System.err.println("expratom");}
{
	glvn() 
	| expritem() 
	| "@" expratom()
}

void exprtail() : {} // TODO
{
	 "."
}

void glvn() : {} 
{
	lvn() | gvn () | ssvn() 
}

void lvn() : {} 
{
	<NAME> ( "(" ( exprlist() )? ")" )?
}

void exprlist() : {}  // TODO
{
	expr() ("," expr())* 
}

void gvn() : {}
{
	"^" lvn()
}

void ssvn() : {}  // TODO
{
	 "."
}

void expritem() : {}  // TODO
{
// strlit
// numlit
// exfunc
// exvar 
// svn
// function
// unaryop expratom
// ( expr )

	<NUMBER> 
       | <STRLIT>
       | unaryop() expratom()
       | "(" expr() ")"
}

void unaryop() : {}
{
	"\'" | "+" | "-"
}
